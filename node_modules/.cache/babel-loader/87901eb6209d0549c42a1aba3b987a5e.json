{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = e(require(\"react\")) : \"function\" == typeof define && define.amd ? define([\"react\"], e) : \"object\" == typeof exports ? exports.Particles = e(require(\"react\")) : t.Particles = e(t.React);\n}(this, function (t) {\n  return function (t) {\n    var e = {};\n\n    function i(o) {\n      if (e[o]) return e[o].exports;\n      var n = e[o] = {\n        i: o,\n        l: !1,\n        exports: {}\n      };\n      return t[o].call(n.exports, n, n.exports, i), n.l = !0, n.exports;\n    }\n\n    return i.m = t, i.c = e, i.d = function (t, e, o) {\n      i.o(t, e) || Object.defineProperty(t, e, {\n        enumerable: !0,\n        get: o\n      });\n    }, i.r = function (t) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n    }, i.t = function (t, e) {\n      if (1 & e && (t = i(t)), 8 & e) return t;\n      if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n      var o = Object.create(null);\n      if (i.r(o), Object.defineProperty(o, \"default\", {\n        enumerable: !0,\n        value: t\n      }), 2 & e && \"string\" != typeof t) for (var n in t) i.d(o, n, function (e) {\n        return t[e];\n      }.bind(null, n));\n      return o;\n    }, i.n = function (t) {\n      var e = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return i.d(e, \"a\", e), e;\n    }, i.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, i.p = \"\", i(i.s = 42);\n  }([function (t, e, i) {\n    \"use strict\";\n\n    i.d(e, \"a\", function () {\n      return s;\n    });\n\n    var o = i(9),\n        n = function (t, e, i, o) {\n      return new (i || (i = Promise))(function (n, s) {\n        function a(t) {\n          try {\n            c(o.next(t));\n          } catch (t) {\n            s(t);\n          }\n        }\n\n        function r(t) {\n          try {\n            c(o.throw(t));\n          } catch (t) {\n            s(t);\n          }\n        }\n\n        function c(t) {\n          var e;\n          t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) {\n            t(e);\n          })).then(a, r);\n        }\n\n        c((o = o.apply(t, e || [])).next());\n      });\n    };\n\n    class s {\n      static clamp(t, e, i) {\n        return Math.min(Math.max(t, e), i);\n      }\n\n      static isInArray(t, e) {\n        return t === e || e.indexOf(t) > -1;\n      }\n\n      static mix(t, e, i, o) {\n        return (t * i + e * o) / (i + o);\n      }\n\n      static getParticleBaseVelocity(t) {\n        let e;\n\n        switch (t.particles.move.direction) {\n          case o.MoveDirection.top:\n            e = {\n              x: 0,\n              y: -1\n            };\n            break;\n\n          case o.MoveDirection.topRight:\n            e = {\n              x: .5,\n              y: -.5\n            };\n            break;\n\n          case o.MoveDirection.right:\n            e = {\n              x: 1,\n              y: -0\n            };\n            break;\n\n          case o.MoveDirection.bottomRight:\n            e = {\n              x: .5,\n              y: .5\n            };\n            break;\n\n          case o.MoveDirection.bottom:\n            e = {\n              x: 0,\n              y: 1\n            };\n            break;\n\n          case o.MoveDirection.bottomLeft:\n            e = {\n              x: -.5,\n              y: 1\n            };\n            break;\n\n          case o.MoveDirection.left:\n            e = {\n              x: -1,\n              y: 0\n            };\n            break;\n\n          case o.MoveDirection.topLeft:\n            e = {\n              x: -.5,\n              y: -.5\n            };\n            break;\n\n          default:\n            e = {\n              x: 0,\n              y: 0\n            };\n        }\n\n        return e;\n      }\n\n      static getDistanceBetweenCoordinates(t, e) {\n        const i = t.x - e.x,\n              o = t.y - e.y;\n        return Math.sqrt(i * i + o * o);\n      }\n\n      static loadFont(t) {\n        return n(this, void 0, void 0, function* () {\n          try {\n            yield document.fonts.load(\"\".concat(t.weight, \" 36px '\").concat(t.font, \"'\"));\n          } catch (t) {}\n        });\n      }\n\n      static arrayRandomIndex(t) {\n        return Math.floor(Math.random() * t.length);\n      }\n\n      static itemFromArray(t, e) {\n        return t[void 0 !== e ? e : this.arrayRandomIndex(t)];\n      }\n\n      static randomInRange(t, e) {\n        return Math.random() * (e - t) + t;\n      }\n\n      static isPointInside(t, e, i) {\n        return this.areBoundsInside(this.calculateBounds(t, null != i ? i : 0), e);\n      }\n\n      static areBoundsInside(t, e) {\n        return t.left >= 0 && t.right <= e.width && t.top >= 0 && t.bottom <= e.height;\n      }\n\n      static calculateBounds(t, e) {\n        return {\n          bottom: t.y + e,\n          left: t.x - e,\n          right: t.x + e,\n          top: t.y - e\n        };\n      }\n\n    }\n  }, function (t, e, i) {\n    \"use strict\";\n\n    i.d(e, \"a\", function () {\n      return s;\n    });\n    var o = i(0),\n        n = i(2);\n\n    class s {\n      static colorToRgb(t) {\n        let e;\n        if (\"string\" == typeof t.value) e = t.value === n.a.randomColorValue ? {\n          b: Math.floor(256 * Math.random()),\n          g: Math.floor(256 * Math.random()),\n          r: Math.floor(256 * Math.random())\n        } : s.stringToRgb(t.value);else if (t.value instanceof Array) {\n          const i = o.a.itemFromArray(t.value);\n          e = s.stringToRgb(i);\n        } else {\n          const i = t.value;\n          void 0 !== i.r && (e = i);\n          const o = t.value;\n          void 0 !== o.h && (e = s.hslToRgb(o));\n        }\n        return e;\n      }\n\n      static stringToAlpha(t) {\n        var e;\n        return null === (e = s.stringToRgba(t)) || void 0 === e ? void 0 : e.a;\n      }\n\n      static stringToRgb(t) {\n        return s.stringToRgba(t);\n      }\n\n      static hslToRgb(t) {\n        const e = {\n          b: 0,\n          g: 0,\n          r: 0\n        };\n        if (0 === t.s) e.b = t.l, e.g = t.l, e.r = t.l;else {\n          const i = t.l < .5 ? t.l * (1 + t.s) : t.l + t.s - t.l * t.s,\n                o = 2 * t.l - i;\n          e.r = s.hue2rgb(o, i, t.h + 1 / 3), e.g = s.hue2rgb(o, i, t.h), e.b = s.hue2rgb(o, i, t.h - 1 / 3);\n        }\n        return e.r = Math.round(255 * e.r), e.g = Math.round(255 * e.g), e.b = Math.round(255 * e.b), e;\n      }\n\n      static hslaToRgba(t) {\n        const e = s.hslToRgb(t);\n        return {\n          a: t.a,\n          b: e.b,\n          g: e.g,\n          r: e.r\n        };\n      }\n\n      static getRandomRgbColor(t) {\n        var e;\n        const i = t || 0,\n              o = i + i * Math.pow(16, 2) + i * Math.pow(16, 4),\n              n = 16777215 ^ o,\n              s = (Math.random() * n + o).toString(16);\n        return null !== (e = this.stringToRgb(\"#\".concat(s))) && void 0 !== e ? e : {\n          b: 0,\n          g: 0,\n          r: 0\n        };\n      }\n\n      static getStyleFromColor(t, e) {\n        const i = null != e ? e : 1;\n        return \"rgba(\".concat(Math.round(t.r), \", \").concat(Math.round(t.g), \", \").concat(Math.round(t.b), \", \").concat(i, \")\");\n      }\n\n      static hue2rgb(t, e, i) {\n        let o = i;\n        return o < 0 && (o += 1), o > 1 && (o -= 1), o < 1 / 6 ? t + 6 * (e - t) * o : o < .5 ? e : o < 2 / 3 ? t + (e - t) * (2 / 3 - o) * 6 : t;\n      }\n\n      static stringToRgba(t) {\n        if (t.startsWith(\"rgb\")) {\n          const e = /rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([\\d\\.]+)\\s*)?\\)/i.exec(t);\n          return e ? {\n            a: e.length > 4 ? parseFloat(e[5]) : 1,\n            b: parseInt(e[3]),\n            g: parseInt(e[2]),\n            r: parseInt(e[1])\n          } : void 0;\n        }\n\n        if (t.startsWith(\"hsl\")) {\n          const e = /hsla?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([\\d\\.]+)\\s*)?\\)/i.exec(t);\n          return e ? s.hslaToRgba({\n            a: e.length > 4 ? parseFloat(e[5]) : 1,\n            h: parseInt(e[1]),\n            l: parseInt(e[3]),\n            s: parseInt(e[2])\n          }) : void 0;\n        }\n\n        {\n          const e = /^#?([a-f\\d])([a-f\\d])([a-f\\d])([a-f\\d])?$/i,\n                i = t.replace(e, (t, e, i, o, n) => e + e + i + i + o + o + (n ? n + n : \"\")),\n                o = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})?$/i.exec(i);\n          return o ? {\n            a: parseInt(o[4], 16) / 255,\n            b: parseInt(o[3], 16),\n            g: parseInt(o[2], 16),\n            r: parseInt(o[1], 16)\n          } : void 0;\n        }\n      }\n\n    }\n  }, function (t, e, i) {\n    \"use strict\";\n\n    i.d(e, \"a\", function () {\n      return o;\n    });\n\n    class o {}\n\n    o.canvasClass = \"tsparticles-canvas-el\", o.randomColorValue = \"random\", o.touchEndEvent = \"touchend\", o.mouseUpEvent = \"mouseup\", o.mouseMoveEvent = \"mousemove\", o.touchStartEvent = \"touchstart\", o.touchMoveEvent = \"touchmove\", o.mouseLeaveEvent = \"mouseleave\", o.touchCancelEvent = \"touchcancel\", o.resizeEvent = \"resize\", o.visibilityChangeEvent = \"visibilitychange\";\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var o;\n    i.r(e), i.d(e, \"ShapeType\", function () {\n      return o;\n    }), function (t) {\n      t.char = \"char\", t.character = \"character\", t.circle = \"circle\", t.edge = \"edge\", t.heart = \"heart\", t.image = \"image\", t.line = \"line\", t.polygon = \"polygon\", t.square = \"square\", t.star = \"star\", t.triangle = \"triangle\";\n    }(o || (o = {}));\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var o;\n    i.r(e), i.d(e, \"OutMode\", function () {\n      return o;\n    }), function (t) {\n      t.bounce = \"bounce\", t.bounceHorizontal = \"bounce-horizontal\", t.bounceVertical = \"bounce-vertical\", t.out = \"out\", t.destroy = \"destroy\";\n    }(o || (o = {}));\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var o;\n    i.r(e), i.d(e, \"PolygonMaskType\", function () {\n      return o;\n    }), function (t) {\n      t.inline = \"inline\", t.inside = \"inside\", t.outside = \"outside\", t.none = \"none\";\n    }(o || (o = {}));\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var o;\n    i.r(e), i.d(e, \"HoverMode\", function () {\n      return o;\n    }), function (t) {\n      t.bubble = \"bubble\", t.connect = \"connect\", t.grab = \"grab\", t.repulse = \"repulse\", t.slow = \"slow\";\n    }(o || (o = {}));\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var o;\n    i.r(e), i.d(e, \"ClickMode\", function () {\n      return o;\n    }), function (t) {\n      t.bubble = \"bubble\", t.push = \"push\", t.remove = \"remove\", t.repulse = \"repulse\";\n    }(o || (o = {}));\n  }, function (t, e, i) {\n    \"use strict\";\n\n    i.d(e, \"a\", function () {\n      return o;\n    });\n\n    class o {\n      static addShapeDrawer(t, e) {\n        this.drawers[t] || (this.drawers[t] = e);\n      }\n\n      static drawShape(t, e, i, o) {\n        if (!e.shape) return;\n        const n = this.drawers[e.shape];\n        n && n.draw(t, e, i, o);\n      }\n\n    }\n\n    o.drawers = {};\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var o;\n    i.r(e), i.d(e, \"MoveDirection\", function () {\n      return o;\n    }), function (t) {\n      t.bottom = \"bottom\", t.bottomLeft = \"bottom-left\", t.bottomRight = \"bottom-right\", t.left = \"left\", t.none = \"none\", t.right = \"right\", t.top = \"top\", t.topLeft = \"top-left\", t.topRight = \"top-right\";\n    }(o || (o = {}));\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var o;\n    i.r(e), i.d(e, \"PolygonMaskInlineArrangement\", function () {\n      return o;\n    }), function (t) {\n      t.equidistant = \"equidistant\", t.onePerPoint = \"one-per-point\", t.perPoint = \"per-point\", t.randomLength = \"random-length\", t.randomPoint = \"random-point\";\n    }(o || (o = {}));\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var o;\n    i.r(e), i.d(e, \"RotateDirection\", function () {\n      return o;\n    }), function (t) {\n      t.clockwise = \"clockwise\", t.counterClockwise = \"counter-clockwise\", t.random = \"random\";\n    }(o || (o = {}));\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var o;\n    i.r(e), i.d(e, \"ProcessBubbleType\", function () {\n      return o;\n    }), function (t) {\n      t.opacity = \"opacity\", t.size = \"size\";\n    }(o || (o = {}));\n  }, function (t, e, i) {\n    var o = i(33),\n        n = \"object\" == typeof self && self && self.Object === Object && self,\n        s = o || n || Function(\"return this\")();\n    t.exports = s;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var o;\n    i.r(e), i.d(e, \"InteractivityDetect\", function () {\n      return o;\n    }), function (t) {\n      t.canvas = \"canvas\", t.parent = \"parent\", t.window = \"window\";\n    }(o || (o = {}));\n  }, function (t, e, i) {\n    var o = i(58),\n        n = i(64);\n\n    t.exports = function (t, e) {\n      var i = n(t, e);\n      return o(i) ? i : void 0;\n    };\n  }, function (t, e, i) {\n    \"use strict\";\n\n    i.d(e, \"a\", function () {\n      return o;\n    });\n\n    class o {\n      static getPreset(t) {\n        return this.presets[t];\n      }\n\n      static addPreset(t, e) {\n        this.presets[t] || (this.presets[t] = e);\n      }\n\n    }\n\n    o.presets = {};\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var o;\n    i.r(e), i.d(e, \"DivMode\", function () {\n      return o;\n    }), function (t) {\n      t.repulse = \"repulse\";\n    }(o || (o = {}));\n  }, function (t, e, i) {\n    var o = i(48),\n        n = i(49),\n        s = i(50),\n        a = i(51),\n        r = i(52);\n\n    function c(t) {\n      var e = -1,\n          i = null == t ? 0 : t.length;\n\n      for (this.clear(); ++e < i;) {\n        var o = t[e];\n        this.set(o[0], o[1]);\n      }\n    }\n\n    c.prototype.clear = o, c.prototype.delete = n, c.prototype.get = s, c.prototype.has = a, c.prototype.set = r, t.exports = c;\n  }, function (t, e, i) {\n    var o = i(31);\n\n    t.exports = function (t, e) {\n      for (var i = t.length; i--;) if (o(t[i][0], e)) return i;\n\n      return -1;\n    };\n  }, function (t, e, i) {\n    var o = i(26),\n        n = i(60),\n        s = i(61),\n        a = o ? o.toStringTag : void 0;\n\n    t.exports = function (t) {\n      return null == t ? void 0 === t ? \"[object Undefined]\" : \"[object Null]\" : a && a in Object(t) ? n(t) : s(t);\n    };\n  }, function (t, e, i) {\n    var o = i(15)(Object, \"create\");\n    t.exports = o;\n  }, function (t, e, i) {\n    var o = i(73);\n\n    t.exports = function (t, e) {\n      var i = t.__data__;\n      return o(e) ? i[\"string\" == typeof e ? \"string\" : \"hash\"] : i.map;\n    };\n  }, function (t, e) {\n    t.exports = function (t) {\n      return null != t && \"object\" == typeof t;\n    };\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var o;\n    i.r(e), i.d(e, \"PolygonMaskMoveType\", function () {\n      return o;\n    }), function (t) {\n      t.path = \"path\", t.radius = \"radius\";\n    }(o || (o = {}));\n  }, function (t, e, i) {\n    var o = i(15)(i(13), \"Map\");\n    t.exports = o;\n  }, function (t, e, i) {\n    var o = i(13).Symbol;\n    t.exports = o;\n  }, function (t, e) {\n    var i = Array.isArray;\n    t.exports = i;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    i.r(e), i.d(e, \"Options\", function () {\n      return lt;\n    });\n    var o = i(14),\n        n = i(7);\n\n    class s {\n      constructor() {\n        this.enable = !1, this.mode = n.ClickMode.push;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode));\n      }\n\n    }\n\n    var a = i(17);\n\n    class r {\n      constructor() {\n        this.elementId = \"repulse-div\", this.enable = !1, this.mode = a.DivMode.repulse;\n      }\n\n      get el() {\n        return this.elementId;\n      }\n\n      set el(t) {\n        this.elementId = t;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.elementId ? this.elementId = t.elementId : void 0 !== t.el && (this.el = t.el), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode));\n      }\n\n    }\n\n    var c = i(6);\n\n    class l {\n      constructor() {\n        this.enable = !1, this.force = 2, this.smooth = 10;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.force && (this.force = t.force), void 0 !== t.smooth && (this.smooth = t.smooth));\n      }\n\n    }\n\n    class h {\n      constructor() {\n        this.enable = !1, this.mode = c.HoverMode.grab, this.parallax = new l();\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode), this.parallax.load(t.parallax));\n      }\n\n    }\n\n    class d {\n      constructor() {\n        this.onClick = new s(), this.onDiv = new r(), this.onHover = new h(), this.resize = !0;\n      }\n\n      get onclick() {\n        return this.onClick;\n      }\n\n      set onclick(t) {\n        this.onClick = t;\n      }\n\n      get ondiv() {\n        return this.onDiv;\n      }\n\n      set ondiv(t) {\n        this.onDiv = t;\n      }\n\n      get onhover() {\n        return this.onHover;\n      }\n\n      set onhover(t) {\n        this.onHover = t;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.onClick ? this.onClick.load(t.onClick) : void 0 !== t.onclick && this.onclick.load(t.onclick), void 0 !== t.onDiv ? this.onDiv.load(t.onDiv) : void 0 !== t.ondiv && this.ondiv.load(t.ondiv), void 0 !== t.onHover ? this.onHover.load(t.onHover) : void 0 !== t.onhover && this.onhover.load(t.onhover), void 0 !== t.resize && (this.resize = t.resize));\n      }\n\n    }\n\n    class u {\n      constructor() {\n        this.distance = 200, this.duration = .4, this.opacity = 1, this.size = 80;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.duration && (this.duration = t.duration), void 0 !== t.opacity && (this.opacity = t.opacity), void 0 !== t.size && (this.size = t.size));\n      }\n\n    }\n\n    class p {\n      constructor() {\n        this.opacity = .5;\n      }\n\n      load(t) {\n        void 0 !== t && void 0 !== t.opacity && (this.opacity = t.opacity);\n      }\n\n    }\n\n    class v {\n      constructor() {\n        this.distance = 80, this.lineLinked = new p(), this.radius = 60;\n      }\n\n      get line_linked() {\n        return this.lineLinked;\n      }\n\n      set line_linked(t) {\n        this.lineLinked = t;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.lineLinked ? this.lineLinked.load(t.lineLinked) : void 0 !== t.line_linked && this.line_linked.load(t.line_linked), void 0 !== t.radius && (this.radius = t.radius));\n      }\n\n    }\n\n    class y {\n      constructor() {\n        this.opacity = 1;\n      }\n\n      load(t) {\n        void 0 !== t && void 0 !== t.opacity && (this.opacity = t.opacity);\n      }\n\n    }\n\n    class f {\n      constructor() {\n        this.distance = 100, this.lineLinked = new y();\n      }\n\n      get line_linked() {\n        return this.lineLinked;\n      }\n\n      set line_linked(t) {\n        this.lineLinked = t;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.lineLinked ? this.lineLinked.load(t.lineLinked) : void 0 !== t.line_linked && this.line_linked.load(t.line_linked));\n      }\n\n    }\n\n    class m {\n      constructor() {\n        this.quantity = 2;\n      }\n\n      get particles_nb() {\n        return this.quantity;\n      }\n\n      set particles_nb(t) {\n        this.quantity = t;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.quantity ? this.quantity = t.quantity : void 0 !== t.particles_nb && (this.particles_nb = t.particles_nb));\n      }\n\n    }\n\n    class g {\n      constructor() {\n        this.quantity = 4;\n      }\n\n      get particles_nb() {\n        return this.quantity;\n      }\n\n      set particles_nb(t) {\n        this.quantity = t;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.quantity ? this.quantity = t.quantity : void 0 !== t.particles_nb && (this.particles_nb = t.particles_nb));\n      }\n\n    }\n\n    class b {\n      constructor() {\n        this.distance = 200, this.duration = .4;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.duration && (this.duration = t.duration));\n      }\n\n    }\n\n    class w {\n      constructor() {\n        this.factor = 1, this.radius = 0;\n      }\n\n      get active() {\n        return !1;\n      }\n\n      set active(t) {}\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.factor && (this.factor = t.factor), void 0 !== t.radius && (this.radius = t.radius));\n      }\n\n    }\n\n    class x {\n      constructor() {\n        this.bubble = new u(), this.connect = new v(), this.grab = new f(), this.push = new g(), this.remove = new m(), this.repulse = new b(), this.slow = new w();\n      }\n\n      load(t) {\n        void 0 !== t && (this.bubble.load(t.bubble), this.connect.load(t.connect), this.grab.load(t.grab), this.push.load(t.push), this.remove.load(t.remove), this.repulse.load(t.repulse), this.slow.load(t.slow));\n      }\n\n    }\n\n    class k {\n      constructor() {\n        this.detectsOn = o.InteractivityDetect.canvas, this.events = new d(), this.modes = new x();\n      }\n\n      get detect_on() {\n        return this.detectsOn;\n      }\n\n      set detect_on(t) {\n        this.detectsOn = t;\n      }\n\n      load(t) {\n        var e, i;\n        void 0 !== t && (void 0 !== t.detectsOn ? this.detectsOn = t.detectsOn : void 0 !== t.detect_on && (this.detect_on = t.detect_on), this.events.load(t.events), this.modes.load(t.modes), (null === (i = null === (e = t.modes) || void 0 === e ? void 0 : e.slow) || void 0 === i ? void 0 : i.active) && (this.events.onHover.mode instanceof Array ? this.events.onHover.mode.indexOf(c.HoverMode.slow) < 0 && this.events.onHover.mode.push(c.HoverMode.slow) : this.events.onHover.mode !== c.HoverMode.slow && (this.events.onHover.mode = [this.events.onHover.mode, c.HoverMode.slow])));\n      }\n\n    }\n\n    class P {\n      constructor() {\n        this.value = \"#fff\";\n      }\n\n      load(t) {\n        void 0 !== t && void 0 !== t.value && (this.value = t.value);\n      }\n\n    }\n\n    class _ {\n      constructor() {\n        this.blur = 5, this.color = new P(), this.enable = !1, this.color.value = \"lime\";\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.blur && (this.blur = t.blur), void 0 !== t.color && (\"string\" == typeof this.color ? this.color = t.color : this.color.load(t.color)), void 0 !== t.enable && (this.enable = t.enable));\n      }\n\n    }\n\n    class M {\n      constructor() {\n        this.blink = !1, this.color = new P(), this.consent = !1, this.distance = 100, this.enable = !1, this.opacity = 1, this.shadow = new _(), this.width = 1;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.blink && (this.blink = t.blink), void 0 !== t.color && (\"string\" == typeof t.color ? this.color = t.color : (this.color = new P(), this.color.load(t.color))), void 0 !== t.consent && (this.consent = t.consent), void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.opacity && (this.opacity = t.opacity), this.shadow.load(t.shadow), void 0 !== t.width && (this.width = t.width));\n      }\n\n    }\n\n    class S {\n      constructor() {\n        this.enable = !1, this.rotate = {\n          x: 3e3,\n          y: 3e3\n        };\n      }\n\n      get rotateX() {\n        return this.rotate.x;\n      }\n\n      set rotateX(t) {\n        this.rotate.x = t;\n      }\n\n      get rotateY() {\n        return this.rotate.y;\n      }\n\n      set rotateY(t) {\n        this.rotate.y = t;\n      }\n\n      load(t) {\n        var e, i;\n        void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== (null === (e = t.rotate) || void 0 === e ? void 0 : e.x) ? this.rotate.x = t.rotate.x : void 0 !== t.rotateX && (this.rotateX = t.rotateX), void 0 !== (null === (i = t.rotate) || void 0 === i ? void 0 : i.y) ? this.rotate.y = t.rotate.y : void 0 !== t.rotateY && (this.rotateY = t.rotateY));\n      }\n\n    }\n\n    var C = i(9),\n        T = i(4);\n\n    class O {\n      constructor() {\n        this.enable = !1, this.length = 10, this.fillColor = new P(), this.fillColor.value = \"#000000\";\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.fillColor && (\"string\" == typeof this.fillColor ? this.fillColor = t.fillColor : this.fillColor.load(t.fillColor)), void 0 !== t.length && (this.length = t.length));\n      }\n\n    }\n\n    class A {\n      constructor() {\n        this.attract = new S(), this.collisions = !1, this.direction = C.MoveDirection.none, this.enable = !1, this.outMode = T.OutMode.out, this.random = !1, this.speed = 2, this.straight = !1, this.trail = new O();\n      }\n\n      get bounce() {\n        return this.collisions;\n      }\n\n      set bounce(t) {\n        this.collisions = t;\n      }\n\n      get out_mode() {\n        return this.outMode;\n      }\n\n      set out_mode(t) {\n        this.outMode = t;\n      }\n\n      load(t) {\n        void 0 !== t && (this.attract.load(t.attract), void 0 !== t.collisions ? this.collisions = t.collisions : void 0 !== t.bounce && (this.bounce = t.bounce), void 0 !== t.direction && (this.direction = t.direction), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.outMode ? this.outMode = t.outMode : void 0 !== t.out_mode && (this.out_mode = t.out_mode), void 0 !== t.random && (this.random = t.random), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.straight && (this.straight = t.straight), this.trail.load(t.trail));\n      }\n\n    }\n\n    class R {\n      constructor() {\n        this.enable = !1, this.area = 800;\n      }\n\n      get value_area() {\n        return this.area;\n      }\n\n      set value_area(t) {\n        this.area = t;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.area ? this.area = t.area : void 0 !== t.value_area && (this.value_area = t.value_area));\n      }\n\n    }\n\n    class L {\n      constructor() {\n        this.density = new R(), this.limit = 0, this.value = 100;\n      }\n\n      get max() {\n        return this.limit;\n      }\n\n      set max(t) {\n        this.limit = t;\n      }\n\n      load(t) {\n        void 0 !== t && (this.density.load(t.density), void 0 !== t.max ? this.max = t.max : void 0 !== t.limit && (this.limit = t.limit), void 0 !== t.value && (this.value = t.value));\n      }\n\n    }\n\n    class z {\n      constructor() {\n        this.enable = !1, this.minimumValue = 0, this.speed = 2, this.sync = !1;\n      }\n\n      get opacity_min() {\n        return this.minimumValue;\n      }\n\n      set opacity_min(t) {\n        this.minimumValue = t;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.minimumValue ? this.minimumValue = t.minimumValue : void 0 !== t.opacity_min && (this.opacity_min = t.opacity_min), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.sync && (this.sync = t.sync));\n      }\n\n    }\n\n    class j {\n      constructor() {\n        this.enable = !1, this.minimumValue = 1;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.minimumValue && (this.minimumValue = t.minimumValue));\n      }\n\n    }\n\n    class E {\n      constructor() {\n        this.animation = new z(), this.random = new j(), this.value = 1;\n      }\n\n      get anim() {\n        return this.animation;\n      }\n\n      set anim(t) {\n        this.animation = t;\n      }\n\n      load(t) {\n        if (void 0 !== t) {\n          if (void 0 !== t.animation ? this.animation.load(t.animation) : void 0 !== t.anim && this.anim.load(t.anim), void 0 !== t.random) {\n            const e = this.random;\n            \"boolean\" == typeof t.random ? e.enable = t.random : e.load(t.random);\n          }\n\n          void 0 !== t.value && (this.value = t.value);\n        }\n      }\n\n    }\n\n    var D = i(3);\n\n    class I {\n      constructor() {\n        this.fill = !1, this.font = \"Verdana\", this.style = \"\", this.value = \"*\", this.weight = \"400\", this.fill = !0, this.close = !0;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.fill && (this.fill = t.fill), void 0 !== t.font && (this.font = t.font), void 0 !== t.style && (this.style = t.style), void 0 !== t.value && (this.value = t.value), void 0 !== t.weight && (this.weight = t.weight));\n      }\n\n    }\n\n    class H {\n      constructor() {\n        this.height = 100, this.replaceColor = !0, this.src = \"\", this.width = 100, this.fill = !0, this.close = !0;\n      }\n\n      get replace_color() {\n        return this.replaceColor;\n      }\n\n      set replace_color(t) {\n        this.replaceColor = t;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.height && (this.height = t.height), void 0 !== t.replaceColor ? this.replaceColor = t.replaceColor : void 0 !== t.replace_color && (this.replace_color = t.replace_color), void 0 !== t.src && (this.src = t.src), void 0 !== t.width && (this.width = t.width));\n      }\n\n    }\n\n    class V {\n      constructor() {\n        this.close = !0, this.fill = !0, this.sides = 5;\n      }\n\n      get nb_sides() {\n        return this.sides;\n      }\n\n      set nb_sides(t) {\n        this.sides = t;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.sides ? this.sides = t.sides : void 0 !== t.nb_sides && (this.nb_sides = t.nb_sides));\n      }\n\n    }\n\n    class F {\n      constructor() {\n        this.character = new I(), this.image = new H(), this.polygon = new V(), this.type = D.ShapeType.circle, this.custom = {};\n      }\n\n      get images() {\n        return this.image instanceof Array ? this.image : [];\n      }\n\n      set images(t) {\n        this.image = t;\n      }\n\n      get stroke() {\n        return [];\n      }\n\n      set stroke(t) {}\n\n      load(t) {\n        if (void 0 !== t) {\n          if (void 0 !== t.custom) for (const e in t.custom) {\n            const i = t.custom[e];\n            void 0 !== i && (this.custom[e] = i instanceof Array ? i.filter(t => void 0 !== t).map(t => t) : i);\n          }\n          void 0 !== t.character && (t.character instanceof Array ? this.character = t.character.map(t => {\n            const e = new I();\n            return e.load(t), e;\n          }) : (this.character instanceof Array && (this.character = new I()), this.character.load(t.character))), void 0 !== t.image && (t.image instanceof Array ? this.image = t.image.map(t => {\n            const e = new H();\n            return e.load(t), e;\n          }) : (this.image instanceof Array && (this.image = new H()), this.image.load(t.image))), void 0 !== t.polygon && (t.polygon instanceof Array ? this.polygon = t.polygon.map(t => {\n            const e = new V();\n            return e.load(t), e;\n          }) : (this.polygon instanceof Array && (this.polygon = new V()), this.polygon.load(t.polygon))), void 0 !== t.type && (this.type = t.type);\n        }\n      }\n\n    }\n\n    class B {\n      constructor() {\n        this.enable = !1, this.minimumValue = 0, this.speed = 5, this.sync = !1;\n      }\n\n      get size_min() {\n        return this.minimumValue;\n      }\n\n      set size_min(t) {\n        this.minimumValue = t;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.minimumValue ? this.minimumValue = t.minimumValue : void 0 !== t.size_min && (this.size_min = t.size_min), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.sync && (this.sync = t.sync));\n      }\n\n    }\n\n    class G {\n      constructor() {\n        this.enable = !1, this.minimumValue = 1;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.minimumValue && (this.minimumValue = t.minimumValue));\n      }\n\n    }\n\n    class q {\n      constructor() {\n        this.animation = new B(), this.random = new G(), this.value = 3;\n      }\n\n      get anim() {\n        return this.animation;\n      }\n\n      set anim(t) {\n        this.animation = t;\n      }\n\n      load(t) {\n        if (void 0 !== t) {\n          if (void 0 !== t.animation ? this.animation.load(t.animation) : void 0 !== t.anim && this.anim.load(t.anim), void 0 !== t.random) {\n            const e = this.random;\n            \"boolean\" == typeof t.random ? e.enable = t.random : e.load(t.random);\n          }\n\n          void 0 !== t.value && (this.value = t.value);\n        }\n      }\n\n    }\n\n    class N {\n      constructor() {\n        this.enable = !1, this.speed = 0, this.sync = !1;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.sync && (this.sync = t.sync));\n      }\n\n    }\n\n    var U = i(11);\n\n    class W {\n      constructor() {\n        this.animation = new N(), this.direction = U.RotateDirection.clockwise, this.random = !1, this.value = 0;\n      }\n\n      load(t) {\n        void 0 !== t && (this.animation.load(t.animation), void 0 !== t.random && (this.random = t.random), void 0 !== t.direction && (this.direction = t.direction), void 0 !== t.value && (this.value = t.value));\n      }\n\n    }\n\n    class $ {\n      constructor() {\n        this.blur = 0, this.color = new P(), this.enable = !1, this.offset = {\n          x: 0,\n          y: 0\n        }, this.color.value = \"#000000\";\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.blur && (this.blur = t.blur), void 0 !== t.color && (\"string\" == typeof this.color ? this.color = t.color : this.color.load(t.color)), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.offset && (void 0 !== t.offset.x && (this.offset.x = t.offset.x), void 0 !== t.offset.y && (this.offset.y = t.offset.y)));\n      }\n\n    }\n\n    class X {\n      constructor() {\n        this.color = new P(), this.width = 0, this.opacity = 1, this.color.value = \"#ff0000\";\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.color && (\"string\" == typeof this.color ? this.color = t.color : this.color.load(t.color)), void 0 !== t.width && (this.width = t.width));\n      }\n\n    }\n\n    class Y {\n      constructor() {\n        this.color = new P(), this.lineLinked = new M(), this.move = new A(), this.number = new L(), this.opacity = new E(), this.rotate = new W(), this.shape = new F(), this.size = new q(), this.shadow = new $(), this.stroke = new X();\n      }\n\n      get line_linked() {\n        return this.lineLinked;\n      }\n\n      set line_linked(t) {\n        this.lineLinked = t;\n      }\n\n      load(t) {\n        var e, i, o;\n\n        if (void 0 !== t) {\n          void 0 !== t.color && (t.color instanceof Array ? this.color = t.color.map(t => {\n            const e = new P();\n            return e.load(t), e;\n          }) : (this.color instanceof Array && (this.color = new P()), this.color.load(t.color)));\n          const n = null !== (e = t.lineLinked) && void 0 !== e ? e : t.line_linked;\n          void 0 !== n && this.lineLinked.load(n), this.move.load(t.move), this.number.load(t.number), this.opacity.load(t.opacity), this.rotate.load(t.rotate), this.shape.load(t.shape), this.size.load(t.size), this.shadow.load(t.shadow);\n          const s = null !== (i = t.stroke) && void 0 !== i ? i : null === (o = t.shape) || void 0 === o ? void 0 : o.stroke;\n          void 0 !== s && (s instanceof Array ? this.stroke = s.map(t => {\n            const e = new X();\n            return e.load(t), e;\n          }) : (this.stroke instanceof Array && (this.stroke = new X()), this.stroke.load(s)));\n        }\n      }\n\n    }\n\n    var J = i(5),\n        Q = i(1);\n\n    class Z {\n      constructor() {\n        this.color = new P(), this.width = .5, this.opacity = 1;\n      }\n\n      load(t) {\n        var e, i;\n\n        if (void 0 !== t) {\n          if (void 0 !== t.color) if (\"string\" == typeof t.color) this.color = t.color, this.opacity = null !== (e = Q.a.stringToAlpha(t.color)) && void 0 !== e ? e : this.opacity;else {\n            const e = t.color;\n            this.color = new P(), this.color.load(e), \"string\" == typeof e.value && (this.opacity = null !== (i = Q.a.stringToAlpha(e.value)) && void 0 !== i ? i : this.opacity);\n          }\n          void 0 !== t.opacity && (this.opacity = t.opacity), void 0 !== t.width && (this.width = t.width);\n        }\n      }\n\n    }\n\n    class K {\n      constructor() {\n        this.enable = !1, this.stroke = new Z();\n      }\n\n      get lineWidth() {\n        return 0;\n      }\n\n      set lineWidth(t) {}\n\n      get lineColor() {\n        return \"\";\n      }\n\n      set lineColor(t) {}\n\n      load(t) {\n        var e;\n\n        if (void 0 !== t) {\n          void 0 !== t.enable && (this.enable = t.enable);\n          const i = null !== (e = t.stroke) && void 0 !== e ? e : {\n            color: t.lineColor,\n            width: t.lineWidth\n          };\n          this.stroke.load(i);\n        }\n      }\n\n    }\n\n    var tt = i(24);\n\n    class et {\n      constructor() {\n        this.radius = 10, this.type = tt.PolygonMaskMoveType.path;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.radius && (this.radius = t.radius), void 0 !== t.type && (this.type = t.type));\n      }\n\n    }\n\n    var it = i(10);\n\n    class ot {\n      constructor() {\n        this.arrangement = it.PolygonMaskInlineArrangement.onePerPoint;\n      }\n\n      load(t) {\n        void 0 !== t && void 0 !== t.arrangement && (this.arrangement = t.arrangement);\n      }\n\n    }\n\n    class nt {\n      constructor() {\n        this.draw = new K(), this.enable = !1, this.inline = new ot(), this.move = new et(), this.scale = 1, this.type = J.PolygonMaskType.none, this.url = \"\";\n      }\n\n      get inlineArrangement() {\n        return this.inline.arrangement;\n      }\n\n      set inlineArrangement(t) {\n        this.inline.arrangement = t;\n      }\n\n      load(t) {\n        void 0 !== t && (this.draw.load(t.draw), void 0 !== t.inline ? this.inline.load(t.inline) : void 0 !== t.inlineArrangement && (this.inlineArrangement = t.inlineArrangement), this.move.load(t.move), void 0 !== t.scale && (this.scale = t.scale), void 0 !== t.type && (this.type = t.type), void 0 !== t.enable ? this.enable = t.enable : this.enable = this.type !== J.PolygonMaskType.none, void 0 !== t.url && (this.url = t.url));\n      }\n\n    }\n\n    class st {\n      constructor() {\n        this.color = new P(), this.opacity = 1;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.color && this.color.load(t.color), void 0 !== t.opacity && (this.opacity = t.opacity));\n      }\n\n    }\n\n    class at {\n      constructor() {\n        this.cover = new st(), this.enable = !1;\n      }\n\n      load(t) {\n        void 0 !== t && (void 0 !== t.cover && this.cover.load(t.cover), void 0 !== t.enable && (this.enable = t.enable));\n      }\n\n    }\n\n    var rt = i(16);\n\n    class ct {\n      load(t) {\n        void 0 !== t && (void 0 !== t.color && (\"string\" == typeof t.color ? this.color = t.color : (this.color = new P(), this.color.load(t.color))), void 0 !== t.image && (this.image = t.image), void 0 !== t.position && (this.position = t.position), void 0 !== t.repeat && (this.repeat = t.repeat), void 0 !== t.size && (this.size = t.size), void 0 !== t.opacity && (this.opacity = t.opacity));\n      }\n\n    }\n\n    class lt {\n      constructor() {\n        this.detectRetina = !1, this.fpsLimit = 30, this.interactivity = new k(), this.particles = new Y(), this.polygon = new nt(), this.backgroundMask = new at(), this.pauseOnBlur = !0, this.background = new ct();\n      }\n\n      get fps_limit() {\n        return this.fpsLimit;\n      }\n\n      set fps_limit(t) {\n        this.fpsLimit = t;\n      }\n\n      get retina_detect() {\n        return this.detectRetina;\n      }\n\n      set retina_detect(t) {\n        this.detectRetina = t;\n      }\n\n      load(t) {\n        if (void 0 !== t) {\n          if (void 0 !== t.preset) if (t.preset instanceof Array) for (const e of t.preset) this.importPreset(e);else this.importPreset(t.preset);\n          void 0 !== t.background && this.background.load(t.background), void 0 !== t.detectRetina ? this.detectRetina = t.detectRetina : void 0 !== t.retina_detect && (this.retina_detect = t.retina_detect), void 0 !== t.fpsLimit ? this.fpsLimit = t.fpsLimit : void 0 !== t.fps_limit && (this.fps_limit = t.fps_limit), void 0 !== t.pauseOnBlur && (this.pauseOnBlur = t.pauseOnBlur), this.interactivity.load(t.interactivity), this.particles.load(t.particles), this.polygon.load(t.polygon), this.backgroundMask.load(t.backgroundMask);\n        }\n      }\n\n      importPreset(t) {\n        const e = rt.a.getPreset(t);\n        void 0 !== e && this.load(e);\n      }\n\n    }\n  }, function (t, e, i) {\n    \"use strict\";\n\n    i.r(e), i.d(e, \"Container\", function () {\n      return F;\n    });\n    var o = i(2),\n        n = i(0),\n        s = i(8),\n        a = i(1);\n\n    class r {\n      static paintBase(t, e, i) {\n        t.save(), t.fillStyle = null != i ? i : \"rgba(0,0,0,0)\", t.fillRect(0, 0, e.width, e.height), t.restore();\n      }\n\n      static clear(t, e) {\n        t.clearRect(0, 0, e.width, e.height);\n      }\n\n      static drawPolygonMask(t, e, i) {\n        const o = \"string\" == typeof i.color ? a.a.stringToRgb(i.color) : a.a.colorToRgb(i.color);\n\n        if (o) {\n          t.save(), t.beginPath(), t.moveTo(e[0].x, e[0].y);\n\n          for (let i = 1; i < e.length; i++) t.lineTo(e[i].x, e[i].y);\n\n          t.closePath(), t.strokeStyle = a.a.getStyleFromColor(o), t.lineWidth = i.width, t.stroke(), t.restore();\n        }\n      }\n\n      static drawPolygonMaskPath(t, e, i, o) {\n        t.save(), t.translate(o.x, o.y);\n        const n = \"string\" == typeof i.color ? a.a.stringToRgb(i.color) : a.a.colorToRgb(i.color);\n        n && (t.strokeStyle = a.a.getStyleFromColor(n, i.opacity), t.lineWidth = i.width, t.stroke(e)), t.restore();\n      }\n\n      static drawLineLinked(t, e, i, o, n, s, r, c) {\n        t.save(), n && (t.globalCompositeOperation = \"destination-out\"), s && (t.strokeStyle = a.a.getStyleFromColor(s, r)), t.lineWidth = e, t.beginPath();\n        const l = \"string\" == typeof c.color ? a.a.stringToRgb(c.color) : a.a.colorToRgb(c.color);\n        c.enable && l && (t.shadowBlur = c.blur, t.shadowColor = a.a.getStyleFromColor(l)), t.moveTo(i.x, i.y), t.lineTo(o.x, o.y), t.stroke(), t.closePath(), t.restore();\n      }\n\n      static drawConnectLine(t, e, i, o, n) {\n        t.save(), t.beginPath(), t.lineWidth = e, t.strokeStyle = i, t.moveTo(o.x, o.y), t.lineTo(n.x, n.y), t.stroke(), t.closePath(), t.restore();\n      }\n\n      static gradient(t, e, i, o, n) {\n        const s = Math.floor(i.radius / e.radius);\n        if (!e.color || !i.color) return;\n        const r = e.position,\n              c = i.position,\n              l = t.createLinearGradient(r.x, r.y, c.x, c.y);\n        return l.addColorStop(0, a.a.getStyleFromColor(e.color, n)), l.addColorStop(s > 1 ? 1 : s, a.a.getStyleFromColor(o, n)), l.addColorStop(1, a.a.getStyleFromColor(i.color, n)), l;\n      }\n\n      static drawGrabLine(t, e, i, o, n, s) {\n        t.save(), t.strokeStyle = a.a.getStyleFromColor(n, s), t.lineWidth = e, t.beginPath(), t.moveTo(i.x, i.y), t.lineTo(o.x, o.y), t.stroke(), t.closePath(), t.restore();\n      }\n\n      static drawParticle(t, e, i, o, n, r) {\n        t.save();\n        const c = e.container.options.particles.shadow,\n              l = e.shadowColor;\n        c.enable && l && (t.shadowBlur = c.blur, t.shadowColor = a.a.getStyleFromColor(l), t.shadowOffsetX = c.offset.x, t.shadowOffsetY = c.offset.y), t.fillStyle = i;\n        const h = {\n          x: e.position.x + e.offset.x,\n          y: e.position.y + e.offset.y\n        };\n        t.translate(h.x, h.y), t.beginPath(), 0 !== e.angle && t.rotate(e.angle * Math.PI / 180), o && (t.globalCompositeOperation = \"destination-out\");\n        const d = e.stroke;\n        d.width > 0 && e.strokeColor && (t.strokeStyle = a.a.getStyleFromColor(e.strokeColor, e.stroke.opacity), t.lineWidth = d.width), s.a.drawShape(t, e, n, r), e.close && t.closePath(), d.width > 0 && e.strokeColor && t.stroke(), e.fill && t.fill(), t.restore();\n      }\n\n    }\n\n    class c {\n      constructor(t) {\n        this.container = t, this.dimension = {\n          height: 0,\n          width: 0\n        }, this.context = null, this.generatedCanvas = !1;\n      }\n\n      init() {\n        this.size();\n        const t = this.container.options,\n              e = t.backgroundMask.cover,\n              i = t.particles.move.trail;\n        this.coverColor = a.a.colorToRgb(void 0 !== e.color ? e.color : t.backgroundMask.cover), this.trailFillColor = \"string\" == typeof i.fillColor ? a.a.stringToRgb(i.fillColor) : a.a.colorToRgb(i.fillColor), this.paint();\n      }\n\n      loadCanvas(t, e) {\n        var i;\n        t.className || (t.className = o.a.canvasClass), this.generatedCanvas && (null === (i = this.element) || void 0 === i || i.remove()), this.generatedCanvas = null != e && e, this.element = t, this.dimension.height = t.offsetHeight, this.dimension.width = t.offsetWidth, this.context = this.element.getContext(\"2d\"), this.container.retina.init(), this.initBackground();\n      }\n\n      destroy() {\n        var t;\n        this.generatedCanvas && (null === (t = this.element) || void 0 === t || t.remove()), this.context && r.clear(this.context, this.dimension);\n      }\n\n      size() {\n        this.element && (this.element.width = this.dimension.width, this.element.height = this.dimension.height);\n      }\n\n      paint() {\n        const t = this.container.options;\n        this.context && (t.backgroundMask.enable && t.backgroundMask.cover && this.coverColor ? this.paintBase(a.a.getStyleFromColor(this.coverColor)) : this.paintBase());\n      }\n\n      clear() {\n        const t = this.container.options,\n              e = t.particles.move.trail;\n        t.backgroundMask.enable ? this.paint() : e.enable && e.length > 0 && this.trailFillColor ? this.paintBase(a.a.getStyleFromColor(this.trailFillColor, 1 / e.length)) : this.context && r.clear(this.context, this.dimension);\n      }\n\n      isPointInPath(t, e) {\n        var i, o;\n        return null !== (o = null === (i = this.context) || void 0 === i ? void 0 : i.isPointInPath(t, e.x, e.y)) && void 0 !== o && o;\n      }\n\n      drawPolygonMask() {\n        const t = this.container,\n              e = t.options,\n              i = this.context,\n              o = e.polygon.draw,\n              n = t.polygon,\n              s = n.raw,\n              a = n.polygonPath,\n              c = n.path2DSupported;\n        i && (c && a && n.offset ? r.drawPolygonMaskPath(i, a, o.stroke, n.offset) : s && r.drawPolygonMask(i, s, o.stroke));\n      }\n\n      drawLinkedLine(t, e, i, s, c) {\n        const l = this.container,\n              h = l.options,\n              d = this.context;\n        if (!d) return;\n        let u;\n        if (l.particles.lineLinkedColor === o.a.randomColorValue) u = a.a.getRandomRgbColor();else if (\"mid\" == l.particles.lineLinkedColor && t.color && e.color) {\n          const i = t.color,\n                o = e.color;\n          u = {\n            b: Math.floor(n.a.mix(i.b, o.b, t.radius, e.radius)),\n            g: Math.floor(n.a.mix(i.g, o.g, t.radius, e.radius)),\n            r: Math.floor(n.a.mix(i.r, o.r, t.radius, e.radius))\n          };\n        } else u = l.particles.lineLinkedColor;\n        const p = l.retina.lineLinkedWidth;\n        r.drawLineLinked(d, p, i, s, h.backgroundMask.enable, u, c, h.particles.lineLinked.shadow);\n      }\n\n      drawConnectLine(t, e) {\n        const i = this.lineStyle(t, e);\n        if (!i) return;\n        const o = this.context;\n        o && r.drawConnectLine(o, this.container.retina.lineLinkedWidth, i, t.position, e.position);\n      }\n\n      drawGrabLine(t, e, i) {\n        const n = this.container,\n              s = n.options.particles.lineLinked.color;\n        let c = n.particles.lineLinkedColor || (\"string\" == typeof s ? a.a.stringToRgb(s) : a.a.colorToRgb(s));\n        c == o.a.randomColorValue && (c = a.a.getRandomRgbColor()), n.particles.lineLinkedColor = c;\n        let l = {\n          r: 127,\n          g: 127,\n          b: 127\n        };\n        const h = n.canvas.context;\n        if (!h) return;\n        l = n.particles.lineLinkedColor == o.a.randomColorValue ? a.a.getRandomRgbColor() || l : n.particles.lineLinkedColor || l;\n        const d = {\n          x: t.position.x + t.offset.x,\n          y: t.position.y + t.offset.y\n        };\n        r.drawGrabLine(h, n.retina.lineLinkedWidth, d, i, l, e);\n      }\n\n      drawParticle(t) {\n        const e = this.container.options;\n        let i;\n        const o = void 0 !== t.bubbler.radius ? t.bubbler.radius : t.radius,\n              n = void 0 !== t.bubbler.opacity ? t.bubbler.opacity : t.opacity.value;\n        t.color && (i = a.a.getStyleFromColor(t.color, n)), this.context && i && r.drawParticle(this.context, t, i, e.backgroundMask.enable, o, n);\n      }\n\n      paintBase(t) {\n        this.context && r.paintBase(this.context, this.dimension, t);\n      }\n\n      lineStyle(t, e) {\n        const i = this.container.options.interactivity.modes.connect;\n\n        if (t.color && e.color) {\n          const o = t.color,\n                s = e.color,\n                a = {\n            b: n.a.mix(o.b, s.b, t.radius, e.radius),\n            g: n.a.mix(o.g, s.g, t.radius, e.radius),\n            r: n.a.mix(o.r, s.r, t.radius, e.radius)\n          };\n          if (this.context) return r.gradient(this.context, t, e, a, i.lineLinked.opacity);\n        }\n      }\n\n      initBackground() {\n        const t = this.container.options.background,\n              e = this.element;\n        if (!e) return;\n        const i = e.style;\n\n        if (t.color) {\n          const e = \"string\" == typeof t.color ? a.a.stringToRgb(t.color) : a.a.colorToRgb(t.color);\n          e && (i.backgroundColor = a.a.getStyleFromColor(e, t.opacity));\n        }\n\n        t.image && (i.backgroundImage = t.image), t.position && (i.backgroundPosition = t.position), t.repeat && (i.backgroundRepeat = t.repeat), t.size && (i.backgroundSize = t.size);\n      }\n\n    }\n\n    var l = i(7),\n        h = i(14),\n        d = i(5);\n\n    class u {\n      constructor(t) {\n        this.container = t, this.canPush = !0, this.mouseMoveHandler = t => this.mouseTouchMove(t), this.touchStartHandler = t => this.mouseTouchMove(t), this.touchMoveHandler = t => this.mouseTouchMove(t), this.touchEndHandler = () => this.mouseTouchFinish(), this.mouseLeaveHandler = () => this.mouseTouchFinish(), this.touchCancelHandler = () => this.mouseTouchFinish(), this.touchEndClickHandler = t => this.mouseTouchClick(t), this.mouseUpHandler = t => this.mouseTouchClick(t), this.visibilityChangeHandler = () => this.handleVisibilityChange(), this.resizeHandler = () => this.handleWindowResize();\n      }\n\n      addListeners() {\n        this.manageListeners(!0);\n      }\n\n      removeListeners() {\n        this.manageListeners(!1);\n      }\n\n      manageListeners(t) {\n        const e = this.container,\n              i = e.options;\n        i.interactivity.detectsOn === h.InteractivityDetect.window ? e.interactivity.element = window : i.interactivity.detectsOn === h.InteractivityDetect.parent && e.canvas.element ? e.interactivity.element = e.canvas.element.parentNode : e.interactivity.element = e.canvas.element;\n        const n = e.interactivity.element;\n        n && (i.interactivity.events.onHover.enable || i.interactivity.events.onClick.enable) && (this.manageListener(n, o.a.mouseMoveEvent, this.mouseMoveHandler, t), this.manageListener(n, o.a.touchStartEvent, this.touchStartHandler, t), this.manageListener(n, o.a.touchMoveEvent, this.touchMoveHandler, t), i.interactivity.events.onClick.enable || this.manageListener(n, o.a.touchEndEvent, this.touchEndHandler, t), this.manageListener(n, o.a.mouseLeaveEvent, this.mouseLeaveHandler, t), this.manageListener(n, o.a.touchCancelEvent, this.touchCancelHandler, t)), i.interactivity.events.onClick.enable && n && (this.manageListener(n, o.a.touchEndEvent, this.touchEndClickHandler, t), this.manageListener(n, o.a.mouseUpEvent, this.mouseUpHandler, t)), i.interactivity.events.resize && this.manageListener(window, o.a.resizeEvent, this.resizeHandler, t), document && this.manageListener(document, o.a.visibilityChangeEvent, this.visibilityChangeHandler, t, !1);\n      }\n\n      manageListener(t, e, i, o, n) {\n        o ? this.addListener(t, e, i, n) : this.removeListener(t, e, i, n);\n      }\n\n      addListener(t, e, i, o) {\n        t.addEventListener(e, i, o);\n      }\n\n      removeListener(t, e, i, o) {\n        t.removeEventListener(e, i, o);\n      }\n\n      handleWindowResize() {\n        const t = this.container,\n              e = t.options;\n        t.canvas.element && (t.canvas.dimension.width = t.canvas.element.offsetWidth, t.canvas.dimension.height = t.canvas.element.offsetHeight, t.retina.isRetina && (t.canvas.dimension.width *= t.retina.pxRatio, t.canvas.dimension.height *= t.retina.pxRatio), t.canvas.element.width = t.canvas.dimension.width, t.canvas.element.height = t.canvas.dimension.height, e.particles.move.enable || t.particles.redraw(), t.densityAutoParticles(), t.polygon.redraw());\n      }\n\n      handleVisibilityChange() {\n        const t = this.container;\n        t.options.pauseOnBlur && ((null === document || void 0 === document ? void 0 : document.hidden) ? (t.pageHidden = !0, t.pause()) : (t.pageHidden = !1, t.play()));\n      }\n\n      mouseTouchMove(t) {\n        var e, i, n;\n        const s = this.container,\n              a = s.options;\n        let r;\n\n        if (t.type.startsWith(\"mouse\")) {\n          this.canPush = !0;\n          const e = t;\n\n          if (s.interactivity.element === window && s.canvas.element) {\n            const t = s.canvas.element.getBoundingClientRect();\n            r = {\n              x: e.clientX - t.left,\n              y: e.clientY - t.top\n            };\n          } else if (a.interactivity.detectsOn === h.InteractivityDetect.parent) {\n            const t = e.target,\n                  i = e.currentTarget;\n\n            if (t && i) {\n              const o = t.getBoundingClientRect(),\n                    n = i.getBoundingClientRect();\n              r = {\n                x: e.offsetX + o.left - n.left,\n                y: e.offsetY + o.top - n.top\n              };\n            } else r = {\n              x: e.offsetX || e.clientX,\n              y: e.offsetY || e.clientY\n            };\n          } else r = {\n            x: e.offsetX || e.clientX,\n            y: e.offsetY || e.clientY\n          };\n        } else {\n          this.canPush = \"touchmove\" !== t.type;\n          const o = t,\n                a = o.touches[o.touches.length - 1],\n                c = null === (e = s.canvas.element) || void 0 === e ? void 0 : e.getBoundingClientRect();\n          r = {\n            x: a.clientX - (null !== (i = null == c ? void 0 : c.left) && void 0 !== i ? i : 0),\n            y: a.clientY - (null !== (n = null == c ? void 0 : c.top) && void 0 !== n ? n : 0)\n          };\n        }\n\n        s.interactivity.mouse.position = r, s.retina.isRetina && (s.interactivity.mouse.position.x *= s.retina.pxRatio, s.interactivity.mouse.position.y *= s.retina.pxRatio), s.interactivity.status = o.a.mouseMoveEvent;\n      }\n\n      mouseTouchFinish() {\n        const t = this.container;\n        delete t.interactivity.mouse.position, t.interactivity.status = o.a.mouseLeaveEvent;\n      }\n\n      mouseTouchClick(t) {\n        const e = this.container,\n              i = e.options;\n        i.polygon.enable && i.polygon.type !== d.PolygonMaskType.none && i.polygon.type !== d.PolygonMaskType.inline ? e.polygon.checkInsidePolygon(e.interactivity.mouse.position) && this.doMouseTouchClick(t) : this.doMouseTouchClick(t);\n      }\n\n      doMouseTouchClick(t) {\n        const e = this.container,\n              i = e.options;\n\n        if (this.canPush) {\n          e.interactivity.mouse.position && (e.interactivity.mouse.clickPosition = {\n            x: e.interactivity.mouse.position.x,\n            y: e.interactivity.mouse.position.y\n          }), e.interactivity.mouse.clickTime = new Date().getTime();\n          const t = i.interactivity.modes.push.quantity,\n                o = i.interactivity.modes.remove.quantity;\n\n          switch (i.interactivity.events.onClick.mode) {\n            case l.ClickMode.push:\n              i.particles.move.enable || 1 === i.interactivity.modes.push.quantity ? e.particles.push(t, e.interactivity.mouse) : i.interactivity.modes.push.quantity > 1 && e.particles.push(t);\n              break;\n\n            case l.ClickMode.remove:\n              e.particles.removeQuantity(o);\n              break;\n\n            case l.ClickMode.bubble:\n              e.bubble.clicking = !0;\n              break;\n\n            case l.ClickMode.repulse:\n              e.repulse.clicking = !0, e.repulse.count = 0, e.repulse.finish = !1, setTimeout(() => {\n                e.destroyed || (e.repulse.clicking = !1);\n              }, 1e3 * i.interactivity.modes.repulse.duration);\n          }\n        }\n\n        t.preventDefault(), \"touchend\" === t.type && setTimeout(() => this.mouseTouchFinish(), 500), t.preventDefault();\n      }\n\n    }\n\n    var p = i(12),\n        v = i(6);\n\n    class y {\n      constructor(t, e) {\n        this.container = t, this.particle = e;\n      }\n\n      bubble() {\n        const t = this.container.options,\n              e = t.interactivity.events.onHover.enable,\n              i = t.interactivity.events.onHover.mode,\n              o = t.interactivity.events.onClick.enable,\n              s = t.interactivity.events.onClick.mode;\n        e && n.a.isInArray(v.HoverMode.bubble, i) ? this.hoverBubble() : o && n.a.isInArray(l.ClickMode.bubble, s) && this.clickBubble();\n      }\n\n      init() {\n        const t = this.particle;\n        this.opacity = t.opacity.value, this.radius = t.radius;\n      }\n\n      process(t, e, i) {\n        const o = this.container,\n              n = o.options.interactivity.modes.bubble.duration,\n              s = i.bubbleObj.optValue,\n              a = o.retina.bubbleModeDistance,\n              r = i.particlesObj.optValue,\n              c = i.bubbleObj.value,\n              l = i.particlesObj.value || 0,\n              h = i.type;\n        if (s !== r) if (o.bubble.durationEnd) {\n          if (c) {\n            const t = 2 * s - l - e * (l - s) / n;\n            h === p.ProcessBubbleType.size && (this.radius = t), h === p.ProcessBubbleType.opacity && (this.opacity = t);\n          }\n        } else if (t <= a) {\n          if ((null != c ? c : l) !== s) {\n            const t = l - e * (l - s) / n;\n            h === p.ProcessBubbleType.size && (this.radius = t), h === p.ProcessBubbleType.opacity && (this.opacity = t);\n          }\n        } else h === p.ProcessBubbleType.size && (this.radius = void 0), h === p.ProcessBubbleType.opacity && (this.opacity = void 0);\n      }\n\n      clickBubble() {\n        const t = this.container,\n              e = t.options,\n              i = this.particle,\n              o = t.interactivity.mouse.clickPosition || {\n          x: 0,\n          y: 0\n        },\n              s = n.a.getDistanceBetweenCoordinates(i.position, o),\n              a = (new Date().getTime() - (t.interactivity.mouse.clickTime || 0)) / 1e3;\n\n        if (t.bubble.clicking) {\n          a > e.interactivity.modes.bubble.duration && (t.bubble.durationEnd = !0), a > 2 * e.interactivity.modes.bubble.duration && (t.bubble.clicking = !1, t.bubble.durationEnd = !1);\n          const i = {\n            bubbleObj: {\n              optValue: t.retina.bubbleModeSize,\n              value: this.radius\n            },\n            particlesObj: {\n              optValue: t.retina.sizeValue,\n              value: this.particle.radius\n            },\n            type: p.ProcessBubbleType.size\n          };\n          this.process(s, a, i);\n          const o = {\n            bubbleObj: {\n              optValue: e.interactivity.modes.bubble.opacity,\n              value: this.opacity\n            },\n            particlesObj: {\n              optValue: e.particles.opacity.value,\n              value: this.particle.opacity.value\n            },\n            type: p.ProcessBubbleType.opacity\n          };\n          this.process(s, a, o);\n        }\n      }\n\n      hoverBubble() {\n        const t = this.container,\n              e = this.particle,\n              i = t.interactivity.mouse.position || {\n          x: 0,\n          y: 0\n        },\n              s = n.a.getDistanceBetweenCoordinates(e.position, i),\n              a = 1 - s / t.retina.bubbleModeDistance;\n        s <= t.retina.bubbleModeDistance ? a >= 0 && t.interactivity.status === o.a.mouseMoveEvent && (this.hoverBubbleSize(a), this.hoverBubbleOpacity(a)) : this.init(), t.interactivity.status === o.a.mouseLeaveEvent && this.init();\n      }\n\n      hoverBubbleSize(t) {\n        const e = this.container,\n              i = e.options,\n              o = this.particle,\n              n = i.interactivity.modes.bubble.size,\n              s = i.particles.size.value,\n              a = o.radius;\n\n        if (e.retina.bubbleModeSize > e.retina.sizeValue) {\n          const e = a + n * t;\n          e > a && e <= n && (this.radius = e);\n        } else if (e.retina.bubbleModeSize < e.retina.sizeValue) {\n          const e = a - (s - n) * t;\n          e < a && e >= n && (this.radius = e);\n        }\n      }\n\n      hoverBubbleOpacity(t) {\n        const e = this.container.options,\n              i = this.particle,\n              o = e.interactivity.modes.bubble.opacity,\n              n = e.particles.opacity.value,\n              s = i.opacity.value;\n\n        if (o > n) {\n          const e = s + o * t;\n          e > s && e <= o && (this.opacity = e);\n        } else if (o < n) {\n          const e = s - (n - o) * t;\n          e < s && e >= o && (this.opacity = e);\n        }\n      }\n\n    }\n\n    class f {\n      constructor(t, e) {\n        this.container = t, this.particle = e;\n      }\n\n      draw() {\n        const t = this.container,\n              e = this.particle;\n        t.canvas.drawParticle(e);\n      }\n\n    }\n\n    class m {\n      constructor(t, e) {\n        this.container = t, this.particle = e;\n      }\n\n      grab() {\n        const t = this.container,\n              e = t.options,\n              i = this.particle,\n              s = e.interactivity;\n\n        if (s.events.onHover.enable && t.interactivity.status === o.a.mouseMoveEvent) {\n          const e = t.interactivity.mouse.position || {\n            x: 0,\n            y: 0\n          },\n                o = n.a.getDistanceBetweenCoordinates(i.position, e);\n\n          if (o <= t.retina.grabModeDistance) {\n            const n = s.modes.grab.lineLinked.opacity,\n                  a = n - o * n / t.retina.grabModeDistance;\n            a > 0 && t.canvas.drawGrabLine(i, a, e);\n          }\n        }\n      }\n\n    }\n\n    var g = i(4),\n        b = i(17);\n\n    class w {\n      constructor(t, e) {\n        this.container = t, this.particle = e;\n      }\n\n      repulse() {\n        const t = this.container,\n              e = t.options,\n              i = e.interactivity.events.onHover.enable,\n              s = e.interactivity.events.onClick.enable,\n              a = t.interactivity.status === o.a.mouseMoveEvent,\n              r = e.interactivity.events.onHover.mode,\n              c = e.interactivity.events.onClick.mode,\n              h = e.interactivity.events.onDiv.mode;\n        a && i && n.a.isInArray(v.HoverMode.repulse, r) ? this.hoverRepulse() : s && n.a.isInArray(l.ClickMode.repulse, c) ? this.clickRepulse() : e.interactivity.events.onDiv.enable && n.a.isInArray(b.DivMode.repulse, h) && this.divRepulse();\n      }\n\n      divRepulse() {\n        const t = this.container,\n              e = t.options,\n              i = this.particle,\n              o = document.getElementById(e.interactivity.events.onDiv.elementId),\n              s = {\n          x: o.offsetLeft + o.offsetWidth / 2,\n          y: o.offsetTop + o.offsetHeight / 2\n        };\n        let a = o.offsetWidth / 2;\n        t.retina.isRetina && (s.x *= t.retina.pxRatio, s.y *= t.retina.pxRatio, a *= t.retina.pxRatio);\n        const r = i.position.x - s.x,\n              c = i.position.y - s.y,\n              l = Math.sqrt(r * r + c * c),\n              h = r / l,\n              d = c / l,\n              u = a,\n              p = n.a.clamp(100 * (1 - Math.pow(l / u, 4)), 0, 50);\n        this.particle.position.x += h * p, this.particle.position.y += d * p;\n      }\n\n      clickRepulse() {\n        const t = this.container,\n              e = this.particle;\n\n        if (t.repulse.finish || (t.repulse.count || (t.repulse.count = 0), t.repulse.count++, t.repulse.count === t.particles.count && (t.repulse.finish = !0)), t.repulse.clicking) {\n          const i = t.retina.repulseModeDistance,\n                o = Math.pow(i / 6, 3),\n                n = t.interactivity.mouse.clickPosition || {\n            x: 0,\n            y: 0\n          },\n                s = n.x - e.position.x,\n                a = n.y - e.position.y,\n                r = s * s + a * a,\n                c = -o / r;\n          r <= o && this.processRepulse(s, a, c);\n        } else !1 === t.repulse.clicking && (e.velocity.horizontal = e.initialVelocity.horizontal, e.velocity.vertical = e.initialVelocity.vertical);\n      }\n\n      hoverRepulse() {\n        const t = this.container,\n              e = t.options,\n              i = this.particle,\n              o = t.interactivity.mouse.position || {\n          x: 0,\n          y: 0\n        },\n              s = i.position.x - o.x,\n              a = i.position.y - o.y,\n              r = Math.sqrt(s * s + a * a),\n              c = s / r,\n              l = a / r,\n              h = t.retina.repulseModeDistance,\n              d = n.a.clamp(100 * (1 - Math.pow(r / h, 2)), 0, 50),\n              u = {\n          x: i.position.x + c * d,\n          y: i.position.y + l * d\n        },\n              p = e.particles.move.outMode;\n\n        if (p === g.OutMode.bounce || p === g.OutMode.bounceVertical || p === g.OutMode.bounceHorizontal) {\n          const e = {\n            horizontal: u.x - i.radius > 0 && u.x + i.radius < t.canvas.dimension.width,\n            vertical: u.y - i.radius > 0 && u.y + i.radius < t.canvas.dimension.height\n          };\n          (p === g.OutMode.bounceVertical || e.horizontal) && (i.position.x = u.x), (p === g.OutMode.bounceHorizontal || e.vertical) && (i.position.y = u.y);\n        } else i.position.x = u.x, i.position.y = u.y;\n      }\n\n      processRepulse(t, e, i) {\n        const o = this.container,\n              n = o.options,\n              s = this.particle,\n              a = Math.atan2(e, t);\n        s.velocity.horizontal = i * Math.cos(a), s.velocity.vertical = i * Math.sin(a);\n        const r = n.particles.move.outMode;\n\n        if (r === g.OutMode.bounce || r === g.OutMode.bounceHorizontal || r === g.OutMode.bounceVertical) {\n          const t = {\n            x: s.position.x + s.velocity.horizontal,\n            y: s.position.y + s.velocity.vertical\n          };\n          r !== g.OutMode.bounceVertical && (t.x + s.radius > o.canvas.dimension.width || t.x - s.radius < 0) && (s.velocity.horizontal = -s.velocity.horizontal), r !== g.OutMode.bounceHorizontal && (t.y + s.radius > o.canvas.dimension.height || t.y - s.radius < 0) && (s.velocity.vertical = -s.velocity.vertical);\n        }\n      }\n\n    }\n\n    var x = i(3);\n\n    class k {\n      constructor(t, e) {\n        this.container = t, this.particle = e;\n      }\n\n      move(t) {\n        const e = this.container,\n              i = e.options,\n              o = this.particle;\n\n        if (i.particles.move.enable) {\n          const n = this.getProximitySpeedFactor(),\n                s = i.fpsLimit > 0 ? 60 * t / 1e3 : 3.6,\n                a = e.retina.moveSpeed / 2 * n * s;\n          o.position.x += o.velocity.horizontal * a, o.position.y += o.velocity.vertical * a;\n        }\n\n        this.moveParallax();\n      }\n\n      moveParallax() {\n        const t = this.container,\n              e = t.options;\n        if (!e.interactivity.events.onHover.parallax.enable) return;\n        const i = this.particle,\n              o = e.interactivity.events.onHover.parallax.force,\n              n = t.interactivity.mouse.position || {\n          x: 0,\n          y: 0\n        },\n              s = window.innerHeight / 2,\n              a = window.innerWidth / 2,\n              r = e.interactivity.events.onHover.parallax.smooth,\n              c = (n.x - a) * (i.radius / o),\n              l = (n.y - s) * (i.radius / o);\n        i.offset.x += (c - i.offset.x) / r, i.offset.y += (l - i.offset.y) / r;\n      }\n\n      getProximitySpeedFactor() {\n        const t = this.container,\n              e = t.options,\n              i = this.particle;\n        if (!n.a.isInArray(v.HoverMode.slow, e.interactivity.events.onHover.mode)) return 1;\n        const o = this.container.interactivity.mouse.position;\n        if (!o) return 1;\n        const s = i.position,\n              a = n.a.getDistanceBetweenCoordinates(o, s),\n              r = t.retina.slowModeRadius;\n        return a > r ? 1 : (a / r || 0) / e.interactivity.modes.slow.factor;\n      }\n\n    }\n\n    var P = i(11);\n\n    class _ {\n      constructor(t, e) {\n        this.container = t, this.particle = e, this.mover = new k(t, e);\n      }\n\n      static checkBounds(t, e, i, o) {\n        (t + e > i || t - e < 0) && o();\n      }\n\n      update(t) {\n        this.mover.move(t), this.updateOpacity(), this.updateSize(), this.updateAngle(), this.fixOutOfCanvasPosition(), this.updateOutMode();\n      }\n\n      updateOpacity() {\n        const t = this.container.options,\n              e = this.particle;\n        t.particles.opacity.animation.enable && (e.opacity.status ? (e.opacity.value >= t.particles.opacity.value && (e.opacity.status = !1), e.opacity.value += e.opacity.velocity || 0) : (e.opacity.value <= t.particles.opacity.animation.minimumValue && (e.opacity.status = !0), e.opacity.value -= e.opacity.velocity || 0), e.opacity.value < 0 && (e.opacity.value = 0));\n      }\n\n      updateSize() {\n        const t = this.container,\n              e = t.options,\n              i = this.particle;\n        e.particles.size.animation.enable && (i.size.status ? (i.radius >= t.retina.sizeValue && (i.size.status = !1), i.radius += i.size.velocity || 0) : (i.radius <= e.particles.size.animation.minimumValue && (i.size.status = !0), i.radius -= i.size.velocity || 0), i.radius < 0 && (i.radius = 0));\n      }\n\n      updateAngle() {\n        const t = this.container.options,\n              e = this.particle;\n        if (t.particles.rotate.animation.enable) switch (e.rotateDirection) {\n          case P.RotateDirection.clockwise:\n            e.angle += t.particles.rotate.animation.speed * Math.PI / 18, e.angle > 360 && (e.angle -= 360);\n            break;\n\n          case P.RotateDirection.counterClockwise:\n          default:\n            e.angle -= t.particles.rotate.animation.speed * Math.PI / 18, e.angle < 0 && (e.angle += 360);\n        }\n      }\n\n      fixOutOfCanvasPosition() {\n        const t = this.container,\n              e = t.options,\n              i = this.particle,\n              o = e.particles.move.outMode,\n              s = t.canvas.dimension;\n        let a;\n        if (a = o === g.OutMode.bounce ? {\n          bottom: s.height,\n          left: i.radius,\n          right: s.width,\n          top: i.radius\n        } : o === g.OutMode.bounceHorizontal ? {\n          bottom: s.height + i.radius - i.offset.y,\n          left: i.radius,\n          right: s.width,\n          top: -i.radius - i.offset.y\n        } : o === g.OutMode.bounceVertical ? {\n          bottom: s.height,\n          left: -i.radius - i.offset.x,\n          right: s.width + i.radius + i.offset.x,\n          top: i.radius\n        } : {\n          bottom: s.height + i.radius - i.offset.y,\n          left: -i.radius - i.offset.x,\n          right: s.width + i.radius + i.offset.x,\n          top: -i.radius - i.offset.y\n        }, o === g.OutMode.destroy) n.a.isPointInside(i.position, t.canvas.dimension, i.radius) && t.particles.remove(i);else {\n          const t = n.a.calculateBounds(i.position, i.radius);\n          t.left > s.width - i.offset.x ? (i.position.x = a.left, i.position.y = Math.random() * s.height) : t.right < -i.offset.x && (i.position.x = a.right, i.position.y = Math.random() * s.height), t.top > s.height - i.offset.y ? (i.position.y = a.top, i.position.x = Math.random() * s.width) : t.bottom < -i.offset.y && (i.position.y = a.bottom, i.position.x = Math.random() * s.width);\n        }\n      }\n\n      updateOutMode() {\n        switch (this.container.options.particles.move.outMode) {\n          case g.OutMode.bounce:\n          case g.OutMode.bounceVertical:\n          case g.OutMode.bounceHorizontal:\n            this.updateBounce();\n        }\n      }\n\n      updateBounce() {\n        const t = this.container,\n              e = t.options,\n              i = this.particle;\n        if (e.polygon.enable && e.polygon.type !== d.PolygonMaskType.none && e.polygon.type !== d.PolygonMaskType.inline) t.polygon.checkInsidePolygon(i.position) || this.polygonBounce();else if (e.polygon.enable && e.polygon.type === d.PolygonMaskType.inline) {\n          if (i.initialPosition) {\n            n.a.getDistanceBetweenCoordinates(i.initialPosition, i.position) > t.retina.polygonMaskMoveRadius && this.polygonBounce();\n          }\n        } else {\n          const o = e.particles.move.outMode,\n                n = i.position.x + i.offset.x,\n                s = i.position.y + i.offset.y;\n          o !== g.OutMode.bounce && o !== g.OutMode.bounceHorizontal || _.checkBounds(n, i.radius, t.canvas.dimension.width, () => {\n            i.velocity.horizontal = -i.velocity.horizontal;\n          }), o !== g.OutMode.bounce && o !== g.OutMode.bounceVertical || _.checkBounds(s, i.radius, t.canvas.dimension.height, () => {\n            i.velocity.vertical = -i.velocity.vertical;\n          });\n        }\n      }\n\n      polygonBounce() {\n        const t = this.particle;\n        t.velocity.horizontal = -t.velocity.horizontal + t.velocity.vertical / 2, t.velocity.vertical = -t.velocity.vertical + t.velocity.horizontal / 2;\n      }\n\n    }\n\n    class M {\n      constructor(t, e) {\n        this.container = t, this.particle = e;\n      }\n\n      connect(t) {\n        const e = this.container,\n              i = e.options,\n              o = this.particle;\n\n        if (i.interactivity.events.onHover.enable && \"mousemove\" == e.interactivity.status) {\n          const i = Math.abs(o.position.x - t.position.x),\n                n = Math.abs(o.position.y - t.position.y),\n                s = e.interactivity.mouse.position || {\n            x: 0,\n            y: 0\n          },\n                a = Math.abs(o.position.x - s.x),\n                r = Math.abs(o.position.y - s.y),\n                c = Math.abs(e.retina.connectModeDistance),\n                l = Math.abs(e.retina.connectModeRadius);\n          i < c && n < c && a < l && r < l && e.canvas.drawConnectLine(o, t);\n        }\n      }\n\n    }\n\n    class S {\n      constructor(t, e) {\n        this.container = t, this.particle = e;\n      }\n\n      link(t) {\n        const e = this.container,\n              i = e.options,\n              s = this.particle,\n              r = {\n          x: s.position.x + s.offset.x,\n          y: s.position.y + s.offset.y\n        },\n              c = {\n          x: t.position.x + t.offset.x,\n          y: t.position.y + t.offset.y\n        },\n              l = n.a.getDistanceBetweenCoordinates(r, c),\n              h = i.particles.lineLinked.opacity,\n              d = e.retina.lineLinkedDistance;\n\n        if (l <= d) {\n          const n = h - l * h / d;\n\n          if (n > 0) {\n            if (!e.particles.lineLinkedColor) {\n              const t = i.particles.lineLinked.color;\n              t === o.a.randomColorValue ? i.particles.lineLinked.consent ? e.particles.lineLinkedColor = a.a.stringToRgb(t) : i.particles.lineLinked.blink ? e.particles.lineLinkedColor = o.a.randomColorValue : e.particles.lineLinkedColor = \"mid\" : e.particles.lineLinkedColor = \"string\" == typeof t ? a.a.stringToRgb(t) : a.a.colorToRgb(t);\n            }\n\n            e.canvas.drawLinkedLine(s, t, r, c, n);\n          }\n        }\n      }\n\n    }\n\n    class C {\n      constructor(t, e) {\n        this.container = t, this.particle = e;\n      }\n\n      attract(t) {\n        const e = this.container,\n              i = e.options,\n              o = this.particle,\n              n = o.position.x - t.position.x,\n              s = o.position.y - t.position.y;\n\n        if (Math.sqrt(n * n + s * s) <= e.retina.lineLinkedDistance) {\n          const e = n / (1e3 * i.particles.move.attract.rotate.x),\n                a = s / (1e3 * i.particles.move.attract.rotate.y);\n          o.velocity.horizontal -= e, o.velocity.vertical -= a, t.velocity.horizontal += e, t.velocity.vertical += a;\n        }\n      }\n\n    }\n\n    class T {\n      constructor(t, e) {\n        this.container = t, this.particle = e;\n      }\n\n      collide(t) {\n        const e = this.particle;\n        e !== t && n.a.getDistanceBetweenCoordinates(e.position, t.position) <= (e.bubbler.radius || e.radius) + (t.bubbler.radius || t.radius) && (e.resetVelocity(), t.resetVelocity());\n      }\n\n    }\n\n    class O {\n      constructor(t, e) {\n        this.container = t, this.linker = new S(t, e), this.attracter = new C(t, e), this.collider = new T(t, e);\n      }\n\n      interact(t) {\n        const e = this.container.options;\n        e.particles.lineLinked.enable && this.linker.link(t), e.particles.move.attract.enable && this.attracter.attract(t), e.particles.move.collisions && this.collider.collide(t);\n      }\n\n    }\n\n    class A {\n      constructor(t, e) {\n        var i, o, s, r, c, l, h, u;\n        this.container = t;\n        const p = t.options,\n              v = p.particles.color;\n\n        if (this.size = {}, this.angle = p.particles.rotate.random ? 360 * Math.random() : p.particles.rotate.value, p.particles.rotate.direction == P.RotateDirection.random) {\n          const t = Math.floor(2 * Math.random());\n          this.rotateDirection = t > 0 ? P.RotateDirection.counterClockwise : P.RotateDirection.clockwise;\n        } else this.rotateDirection = p.particles.rotate.direction;\n\n        const g = p.particles.size.random,\n              b = t.retina.sizeValue;\n        this.radius = g.enable ? n.a.randomInRange(g.minimumValue, b) : b, p.particles.size.animation.enable && (this.size.status = !1, this.size.velocity = t.retina.sizeAnimationSpeed / 100, p.particles.size.animation.sync || (this.size.velocity = this.size.velocity * Math.random())), p.particles.rotate.animation.enable && (p.particles.rotate.animation.sync || (this.angle = 360 * Math.random())), this.position = this.calcPosition(this.container, e), p.polygon.enable && p.polygon.type === d.PolygonMaskType.inline && (this.initialPosition = {\n          x: this.position.x,\n          y: this.position.y\n        }), this.offset = {\n          x: 0,\n          y: 0\n        }, p.particles.move.collisions && this.checkOverlap(e), this.color = v instanceof Array ? a.a.colorToRgb(n.a.itemFromArray(v)) : a.a.colorToRgb(v);\n        const k = p.particles.opacity.random,\n              S = p.particles.opacity.value;\n        this.opacity = {\n          value: k.enable ? n.a.randomInRange(k.minimumValue, S) : S\n        }, p.particles.opacity.animation.enable && (this.opacity.status = !1, this.opacity.velocity = p.particles.opacity.animation.speed / 100, p.particles.opacity.animation.sync || (this.opacity.velocity *= Math.random())), this.initialVelocity = A.calculateVelocity(p), this.velocity = {\n          horizontal: this.initialVelocity.horizontal,\n          vertical: this.initialVelocity.vertical\n        }, this.fill = !0, this.close = !0;\n        const C = p.particles.shape.type;\n\n        if (this.shape = C instanceof Array ? n.a.itemFromArray(C) : C, this.shape === x.ShapeType.image) {\n          const e = p.particles.shape,\n                s = n.a.arrayRandomIndex(t.images),\n                a = t.images[s],\n                r = e.image instanceof Array ? e.image[s] : e.image;\n          this.image = {\n            data: a,\n            ratio: r.width / r.height,\n            replaceColor: r.replaceColor,\n            src: r.src\n          }, this.image.ratio || (this.image.ratio = 1), this.fill = null !== (i = r.fill) && void 0 !== i ? i : this.fill, this.close = null !== (o = r.close) && void 0 !== o ? o : this.close;\n        }\n\n        if (this.shape === x.ShapeType.polygon && (p.particles.shape.polygon instanceof Array ? this.polygon = n.a.itemFromArray(p.particles.shape.polygon) : this.polygon = p.particles.shape.polygon, this.fill = null !== (s = this.polygon.fill) && void 0 !== s ? s : this.fill, this.close = null !== (r = this.polygon.close) && void 0 !== r ? r : this.close), p.particles.stroke instanceof Array ? this.stroke = n.a.itemFromArray(p.particles.stroke) : this.stroke = p.particles.stroke, this.strokeColor = \"string\" == typeof this.stroke.color ? a.a.stringToRgb(this.stroke.color) : a.a.colorToRgb(this.stroke.color), this.shadowColor = \"string\" == typeof p.particles.shadow.color ? a.a.stringToRgb(p.particles.shadow.color) : a.a.colorToRgb(p.particles.shadow.color), this.shape === x.ShapeType.char || this.shape === x.ShapeType.character) {\n          p.particles.shape.character instanceof Array ? this.character = n.a.itemFromArray(p.particles.shape.character) : this.character = p.particles.shape.character;\n          const t = this.character.value;\n          this.text = t instanceof Array ? n.a.itemFromArray(t) : t, this.fill = null !== (c = this.character.fill) && void 0 !== c ? c : this.fill, this.close = null !== (l = this.character.close) && void 0 !== l ? l : this.close;\n        }\n\n        const T = p.particles.shape.custom[this.shape];\n        T && (this.shapeData = T instanceof Array ? n.a.itemFromArray(T) : T, this.fill = null !== (h = this.shapeData.fill) && void 0 !== h ? h : this.fill, this.close = null !== (u = this.shapeData.close) && void 0 !== u ? u : this.close), this.updater = new _(this.container, this), this.bubbler = new y(this.container, this), this.repulser = new w(this.container, this), this.drawer = new f(this.container, this), this.grabber = new m(this.container, this), this.connecter = new M(this.container, this), this.interactionManager = new O(this.container, this);\n      }\n\n      static calculateVelocity(t) {\n        const e = n.a.getParticleBaseVelocity(t),\n              i = {\n          horizontal: 0,\n          vertical: 0\n        };\n        return t.particles.move.straight ? (i.horizontal = e.x, i.vertical = e.y, t.particles.move.random && (i.horizontal *= Math.random(), i.vertical *= Math.random())) : (i.horizontal = e.x + Math.random() - .5, i.vertical = e.y + Math.random() - .5), i;\n      }\n\n      resetVelocity() {\n        const t = this.container.options,\n              e = A.calculateVelocity(t);\n        this.velocity.horizontal = e.horizontal, this.velocity.vertical = e.vertical;\n      }\n\n      update(t, e) {\n        const i = this.container,\n              o = i.options;\n        this.updater.update(e);\n        const s = o.interactivity.events.onHover.mode,\n              a = o.interactivity.events.onClick.mode;\n        if (n.a.isInArray(v.HoverMode.grab, s) && this.grabber.grab(), n.a.isInArray(v.HoverMode.connect, o.interactivity.events.onHover.mode)) for (let e = t + 1; e < i.particles.count; e++) {\n          const t = i.particles.array[e];\n          this.connecter.connect(t);\n        }\n        (n.a.isInArray(v.HoverMode.bubble, s) || n.a.isInArray(l.ClickMode.bubble, a)) && this.bubbler.bubble(), (n.a.isInArray(v.HoverMode.repulse, s) || n.a.isInArray(l.ClickMode.repulse, a)) && this.repulser.repulse();\n      }\n\n      interact(t) {\n        this.interactionManager.interact(t);\n      }\n\n      draw() {\n        this.drawer.draw();\n      }\n\n      isOverlapping() {\n        const t = this.container,\n              e = this;\n        let i = !1,\n            o = 0;\n\n        for (const s of t.particles.array.filter(t => t != e)) {\n          if (o++, n.a.getDistanceBetweenCoordinates(e.position, s.position) <= e.radius + s.radius) {\n            i = !0;\n            break;\n          }\n        }\n\n        return {\n          collisionFound: i,\n          iterations: o\n        };\n      }\n\n      checkOverlap(t) {\n        const e = this.container,\n              i = this,\n              o = i.isOverlapping();\n        o.iterations >= e.particles.count ? e.particles.remove(this) : o.collisionFound && (i.position.x = t ? t.x : Math.random() * e.canvas.dimension.width, i.position.y = t ? t.y : Math.random() * e.canvas.dimension.height, i.checkOverlap());\n      }\n\n      calcPosition(t, e) {\n        var i, o;\n        const n = {\n          x: 0,\n          y: 0\n        };\n        if (t.options.polygon.enable && (null !== (o = null === (i = t.polygon.raw) || void 0 === i ? void 0 : i.length) && void 0 !== o ? o : 0) > 0) {\n          if (e) n.x = e.x, n.y = e.y;else {\n            const e = t.polygon.randomPointInPolygon();\n            n.x = e.x, n.y = e.y;\n          }\n        } else n.x = e ? e.x : Math.random() * t.canvas.dimension.width, n.y = e ? e.y : Math.random() * t.canvas.dimension.height, n.x > t.canvas.dimension.width - 2 * this.radius ? n.x -= this.radius : n.x < 2 * this.radius && (n.x += this.radius), n.y > t.canvas.dimension.height - 2 * this.radius ? n.y -= this.radius : n.y < 2 * this.radius && (n.y += this.radius);\n        return n;\n      }\n\n    }\n\n    var R = i(10);\n\n    class L {\n      constructor(t) {\n        this.container = t, this.array = [], this.interactionsEnabled = !1;\n      }\n\n      get count() {\n        return this.array.length;\n      }\n\n      init() {\n        const t = this.container,\n              e = t.options;\n        if (e.polygon.enable && e.polygon.type === d.PolygonMaskType.inline && e.polygon.inline.arrangement === R.PolygonMaskInlineArrangement.onePerPoint) t.polygon.drawPointsOnPolygonPath();else for (let i = this.array.length; i < e.particles.number.value; i++) this.addParticle(new A(t));\n        this.interactionsEnabled = e.particles.lineLinked.enable || e.particles.move.attract.enable || e.particles.move.collisions;\n      }\n\n      redraw() {\n        this.clear(), this.init(), this.draw(0);\n      }\n\n      removeAt(t, e) {\n        t >= 0 && t <= this.count && this.array.splice(t, null != e ? e : 1);\n      }\n\n      remove(t) {\n        this.removeAt(this.array.indexOf(t));\n      }\n\n      update(t) {\n        for (let e = 0; e < this.array.length; e++) {\n          const i = this.array[e];\n          if (i.update(e, t), this.interactionsEnabled) for (let t = e + 1; t < this.array.length; t++) {\n            const e = this.array[t];\n            i.interact(e);\n          }\n        }\n      }\n\n      draw(t) {\n        const e = this.container,\n              i = e.options;\n        e.canvas.clear(), this.update(t), i.polygon.enable && i.polygon.draw.enable && e.polygon.drawPolygon();\n\n        for (const t of this.array) t.draw();\n      }\n\n      clear() {\n        this.array = [];\n      }\n\n      push(t, e) {\n        var i;\n        const o = this.container,\n              n = o.options;\n        let s;\n        this.pushing = !0, n.particles.number.limit > 0 && this.array.length + t > n.particles.number.limit && this.removeQuantity(this.array.length + t - n.particles.number.limit), e && (s = null !== (i = e.position) && void 0 !== i ? i : {\n          x: 0,\n          y: 0\n        });\n\n        for (let e = 0; e < t; e++) this.addParticle(new A(o, s));\n\n        n.particles.move.enable || this.container.play(), this.pushing = !1;\n      }\n\n      addParticle(t) {\n        this.array.push(t);\n      }\n\n      removeQuantity(t) {\n        const e = this.container.options;\n        this.removeAt(0, t), e.particles.move.enable || this.container.play();\n      }\n\n    }\n\n    class z {\n      constructor(t) {\n        this.container = t, this.isRetina = !1, this.bubbleModeDistance = 0, this.bubbleModeSize = 0, this.connectModeDistance = 0, this.connectModeRadius = 0, this.grabModeDistance = 0, this.repulseModeDistance = 0, this.slowModeRadius = 0, this.lineLinkedDistance = 0, this.lineLinkedWidth = 0, this.moveSpeed = 0, this.sizeValue = 0, this.sizeAnimationSpeed = 0, this.polygonMaskMoveRadius = 0, this.pxRatio = 1;\n      }\n\n      init() {\n        const t = this.container,\n              e = t.options;\n        e.detectRetina && window.devicePixelRatio > 1 ? (this.pxRatio = window.devicePixelRatio, this.isRetina = !0) : (this.pxRatio = 1, this.isRetina = !1);\n        const i = this.pxRatio;\n        t.canvas.element && (t.canvas.dimension.width = t.canvas.element.offsetWidth * i, t.canvas.dimension.height = t.canvas.element.offsetHeight * i), this.bubbleModeDistance = e.interactivity.modes.bubble.distance * i, this.bubbleModeSize = e.interactivity.modes.bubble.size * i, this.connectModeDistance = e.interactivity.modes.connect.distance * i, this.connectModeRadius = e.interactivity.modes.connect.radius * i, this.grabModeDistance = e.interactivity.modes.grab.distance * i, this.repulseModeDistance = e.interactivity.modes.repulse.distance * i, this.slowModeRadius = e.interactivity.modes.slow.radius * i, this.lineLinkedDistance = e.particles.lineLinked.distance * i, this.lineLinkedWidth = e.particles.lineLinked.width * i, this.moveSpeed = e.particles.move.speed * i, this.sizeValue = e.particles.size.value * i, this.sizeAnimationSpeed = e.particles.size.animation.speed * i, this.polygonMaskMoveRadius = e.polygon.move.radius * i;\n      }\n\n      reset() {}\n\n    }\n\n    var j = function (t, e, i, o) {\n      return new (i || (i = Promise))(function (n, s) {\n        function a(t) {\n          try {\n            c(o.next(t));\n          } catch (t) {\n            s(t);\n          }\n        }\n\n        function r(t) {\n          try {\n            c(o.throw(t));\n          } catch (t) {\n            s(t);\n          }\n        }\n\n        function c(t) {\n          var e;\n          t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) {\n            t(e);\n          })).then(a, r);\n        }\n\n        c((o = o.apply(t, e || [])).next());\n      });\n    };\n\n    class E {\n      constructor(t) {\n        this.container = t, this.dimension = {\n          height: 0,\n          width: 0\n        }, this.polygonPathLength = 0, this.path2DSupported = window.hasOwnProperty(\"Path2D\");\n      }\n\n      checkInsidePolygon(t) {\n        const e = this.container,\n              i = e.options;\n        if (!i.polygon.enable || i.polygon.type === d.PolygonMaskType.none || i.polygon.type === d.PolygonMaskType.inline) return !0;\n        if (!this.raw) return console.error(\"No polygon found, you need to specify SVG url in config.\"), !0;\n        const o = t ? t.x : Math.random() * e.canvas.dimension.width,\n              n = t ? t.y : Math.random() * e.canvas.dimension.height;\n        let s = !1;\n\n        for (let t = 0, e = this.raw.length - 1; t < this.raw.length; e = t++) {\n          const i = this.raw[t].x,\n                a = this.raw[t].y,\n                r = this.raw[e].x,\n                c = this.raw[e].y;\n          a > n != c > n && o < (r - i) * (n - a) / (c - a) + i && (s = !s);\n        }\n\n        return i.polygon.type === d.PolygonMaskType.inside ? s : i.polygon.type === d.PolygonMaskType.outside && !s;\n      }\n\n      redraw() {\n        const t = this.container,\n              e = t.options;\n        e.polygon.enable && e.polygon.type !== d.PolygonMaskType.none && (this.redrawTimeout && clearTimeout(this.redrawTimeout), this.redrawTimeout = setTimeout(() => {\n          this.parseSvgPathToPolygon().then(e => {\n            this.raw = e, this.createPath2D(), t.particles.redraw();\n          });\n        }, 250));\n      }\n\n      init() {\n        return j(this, void 0, void 0, function* () {\n          const t = this.container.options;\n          t.polygon.enable && t.polygon.url && (this.raw = yield this.parseSvgPathToPolygon(t.polygon.url), this.createPath2D());\n        });\n      }\n\n      reset() {\n        delete this.raw, delete this.path, delete this.svg;\n      }\n\n      randomPointInPolygon() {\n        const t = this.container,\n              e = t.options;\n        let i;\n        if (e.polygon.type === d.PolygonMaskType.inline) switch (e.polygon.inline.arrangement) {\n          case R.PolygonMaskInlineArrangement.randomPoint:\n            i = this.getRandomPointOnPolygonPath();\n            break;\n\n          case R.PolygonMaskInlineArrangement.randomLength:\n            i = this.getRandomPointOnPolygonPathByLength();\n            break;\n\n          case R.PolygonMaskInlineArrangement.equidistant:\n            i = this.getEquidistantPointOnPolygonPathByIndex(t.particles.count);\n            break;\n\n          case R.PolygonMaskInlineArrangement.onePerPoint:\n          default:\n            i = this.getPoingOnPolygonPathByIndex(t.particles.count);\n        } else i = {\n          x: Math.random() * t.canvas.dimension.width,\n          y: Math.random() * t.canvas.dimension.height\n        };\n        return this.checkInsidePolygon(i) ? i : this.randomPointInPolygon();\n      }\n\n      parseSvgPathToPolygon(t) {\n        return j(this, void 0, void 0, function* () {\n          const e = this.container,\n                i = e.options,\n                o = t || i.polygon.url;\n\n          if (!this.path || !this.svg) {\n            const t = yield fetch(o);\n            if (!t.ok) return void console.error(\"tsParticles Error - during polygon mask download\");\n            {\n              const e = yield t.text(),\n                    i = new DOMParser().parseFromString(e, \"image/svg+xml\");\n              this.svg = i.getElementsByTagName(\"svg\")[0], this.path = i.getElementsByTagName(\"path\")[0], this.path && (this.polygonPathLength = this.path.getTotalLength());\n            }\n          }\n\n          const n = i.polygon.scale;\n          this.dimension.width = parseFloat(this.svg.getAttribute(\"width\") || \"0\") * n, this.dimension.height = parseFloat(this.svg.getAttribute(\"height\") || \"0\") * n, this.offset = {\n            x: e.canvas.dimension.width / 2 - this.dimension.width / 2,\n            y: e.canvas.dimension.height / 2 - this.dimension.height / 2\n          };\n          const s = this.path.pathSegList.numberOfItems,\n                a = [],\n                r = {\n            x: 0,\n            y: 0\n          };\n\n          for (let t = 0; t < s; t++) {\n            const e = this.path.pathSegList.getItem(t);\n\n            switch (e.pathSegType) {\n              case window.SVGPathSeg.PATHSEG_MOVETO_ABS:\n              case window.SVGPathSeg.PATHSEG_LINETO_ABS:\n              case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n              case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n              case window.SVGPathSeg.PATHSEG_ARC_ABS:\n              case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n              case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n                const t = e;\n                r.x = t.x, r.y = t.y;\n                break;\n\n              case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n                r.x = e.x;\n                break;\n\n              case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n                r.y = e.y;\n                break;\n\n              case window.SVGPathSeg.PATHSEG_LINETO_REL:\n              case window.SVGPathSeg.PATHSEG_MOVETO_REL:\n              case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n              case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n              case window.SVGPathSeg.PATHSEG_ARC_REL:\n              case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n              case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n                const i = e;\n                r.x += i.x, r.y += i.y;\n                break;\n\n              case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n                r.x += e.x;\n                break;\n\n              case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n                r.y += e.y;\n                break;\n\n              case window.SVGPathSeg.PATHSEG_UNKNOWN:\n              case window.SVGPathSeg.PATHSEG_CLOSEPATH:\n                continue;\n            }\n\n            a.push({\n              x: r.x * n + this.offset.x,\n              y: r.y * n + this.offset.y\n            });\n          }\n\n          return a;\n        });\n      }\n\n      drawPolygon() {\n        this.container.canvas.drawPolygonMask();\n      }\n\n      drawPointsOnPolygonPath() {\n        const t = this.container;\n        if (this.raw) for (const e of this.raw) {\n          const i = {\n            x: e.x,\n            y: e.y\n          };\n          t.particles.addParticle(new A(t, i));\n        }\n      }\n\n      getRandomPointOnPolygonPath() {\n        if (!this.raw || !this.raw.length) throw new Error(\"No polygon data loaded.\");\n        const t = n.a.itemFromArray(this.raw);\n        return {\n          x: t.x,\n          y: t.y\n        };\n      }\n\n      getRandomPointOnPolygonPathByLength() {\n        var t, e;\n        const i = this.container.options;\n        if (!this.raw || !this.raw.length || !this.path) throw new Error(\"No polygon data loaded.\");\n        const o = Math.floor(Math.random() * this.polygonPathLength) + 1,\n              n = this.path.getPointAtLength(o);\n        return {\n          x: n.x * i.polygon.scale + ((null === (t = this.offset) || void 0 === t ? void 0 : t.x) || 0),\n          y: n.y * i.polygon.scale + ((null === (e = this.offset) || void 0 === e ? void 0 : e.y) || 0)\n        };\n      }\n\n      getEquidistantPointOnPolygonPathByIndex(t) {\n        var e, i;\n        const o = this.container.options;\n        if (!this.raw || !this.raw.length || !this.path) throw new Error(\"No polygon data loaded.\");\n        const n = this.polygonPathLength / o.particles.number.value * t,\n              s = this.path.getPointAtLength(n);\n        return {\n          x: s.x * o.polygon.scale + ((null === (e = this.offset) || void 0 === e ? void 0 : e.x) || 0),\n          y: s.y * o.polygon.scale + ((null === (i = this.offset) || void 0 === i ? void 0 : i.y) || 0)\n        };\n      }\n\n      getPoingOnPolygonPathByIndex(t) {\n        if (!this.raw || !this.raw.length) throw new Error(\"No polygon data loaded.\");\n        const e = this.raw[t % this.raw.length];\n        return {\n          x: e.x,\n          y: e.y\n        };\n      }\n\n      createPath2D() {\n        var t;\n        if (!this.path2DSupported) return;\n        const e = null === (t = this.path) || void 0 === t ? void 0 : t.getAttribute(\"d\");\n\n        if (e) {\n          const t = new Path2D(e),\n                i = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGMatrix(),\n                o = new Path2D(),\n                n = i.scale(this.container.options.polygon.scale);\n          o.addPath ? (o.addPath(t, n), this.polygonPath = o) : delete this.polygonPath;\n        } else delete this.polygonPath;\n\n        !this.polygonPath && this.raw && (this.polygonPath = new Path2D(), this.polygonPath.moveTo(this.raw[0].x, this.raw[0].y), this.raw.forEach((t, e) => {\n          var i;\n          e > 0 && (null === (i = this.polygonPath) || void 0 === i || i.lineTo(t.x, t.y));\n        }), this.polygonPath.closePath());\n      }\n\n    }\n\n    class D {\n      constructor(t) {\n        this.container = t;\n      }\n\n      nextFrame(t) {\n        const e = this.container,\n              i = e.options,\n              o = i.fpsLimit > 0 ? i.fpsLimit : 60;\n        if (void 0 !== e.lastFrameTime && t < e.lastFrameTime + 1e3 / o) return void e.play();\n        const n = t - e.lastFrameTime;\n        e.lastFrameTime = t, i.particles.shape.type === x.ShapeType.image && e.images.every(t => t.error) || (e.particles.draw(n), i.particles.move.enable ? e.play() : e.pause());\n      }\n\n    }\n\n    var I = i(28),\n        H = i(16),\n        V = function (t, e, i, o) {\n      return new (i || (i = Promise))(function (n, s) {\n        function a(t) {\n          try {\n            c(o.next(t));\n          } catch (t) {\n            s(t);\n          }\n        }\n\n        function r(t) {\n          try {\n            c(o.throw(t));\n          } catch (t) {\n            s(t);\n          }\n        }\n\n        function c(t) {\n          var e;\n          t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) {\n            t(e);\n          })).then(a, r);\n        }\n\n        c((o = o.apply(t, e || [])).next());\n      });\n    };\n\n    class F {\n      constructor(t, e, ...i) {\n        this.started = !1, this.destroyed = !1, this.id = t, this.paused = !0, this.sourceOptions = e, this.lastFrameTime = 0, this.pageHidden = !1, this.retina = new z(this), this.canvas = new c(this), this.particles = new L(this), this.polygon = new E(this), this.drawer = new D(this), this.interactivity = {\n          mouse: {}\n        }, this.images = [], this.bubble = {}, this.repulse = {}, this.options = new I.Options();\n\n        for (const t of i) this.options.load(H.a.getPreset(t));\n\n        this.sourceOptions && this.options.load(this.sourceOptions), this.eventListeners = new u(this);\n      }\n\n      static requestFrame(t) {\n        return window.customRequestAnimationFrame(t);\n      }\n\n      static cancelAnimation(t) {\n        window.cancelAnimationFrame(t);\n      }\n\n      play() {\n        this.paused && (this.lastFrameTime = performance.now(), this.paused = !1), this.drawAnimationFrame = F.requestFrame(t => this.drawer.nextFrame(t));\n      }\n\n      pause() {\n        void 0 !== this.drawAnimationFrame && (F.cancelAnimation(this.drawAnimationFrame), delete this.drawAnimationFrame, this.paused = !0);\n      }\n\n      densityAutoParticles() {\n        if (!this.canvas.element || !this.options.particles.number.density.enable) return;\n        let t = this.canvas.element.width * this.canvas.element.height / 1e3;\n        this.retina.isRetina && (t /= 2 * this.retina.pxRatio);\n        const e = t * this.options.particles.number.value / this.options.particles.number.density.area,\n              i = this.particles.count;\n        i < e ? this.particles.push(Math.abs(e - i)) : i > e && this.particles.removeQuantity(i - e);\n      }\n\n      destroy() {\n        this.stop(), this.retina.reset(), this.canvas.destroy(), delete this.interactivity, delete this.options, delete this.retina, delete this.canvas, delete this.particles, delete this.polygon, delete this.bubble, delete this.repulse, delete this.images, delete this.drawer, delete this.eventListeners, this.destroyed = !0;\n      }\n\n      exportImg(t) {\n        this.exportImage(t);\n      }\n\n      exportImage(t, e, i) {\n        var o;\n        return null === (o = this.canvas.element) || void 0 === o ? void 0 : o.toBlob(t, null != e ? e : \"image/png\", i);\n      }\n\n      exportConfiguration() {\n        return JSON.stringify(this.options, void 0, 2);\n      }\n\n      loadImage(t, e) {\n        return new Promise((i, o) => {\n          if (t.error = !1, e.src) {\n            const n = new Image();\n            n.addEventListener(\"load\", () => {\n              t.obj = n, i();\n            }), n.addEventListener(\"error\", () => {\n              t.error = !0, o(\"Error tsParticles - loading image: \".concat(e.src));\n            }), n.src = e.src;\n          } else t.error = !0, o(\"Error tsParticles - No image.src\");\n        });\n      }\n\n      refresh() {\n        return V(this, void 0, void 0, function* () {\n          this.stop(), yield this.start();\n        });\n      }\n\n      stop() {\n        this.started && (this.started = !1, this.eventListeners.removeListeners(), this.pause(), this.images = [], this.particles.clear(), this.retina.reset(), this.canvas.clear(), this.polygon.reset(), delete this.particles.lineLinkedColor);\n      }\n\n      start() {\n        return V(this, void 0, void 0, function* () {\n          if (!this.started) {\n            if (this.started = !0, this.eventListeners.addListeners(), yield this.polygon.init(), n.a.isInArray(x.ShapeType.char, this.options.particles.shape.type) || n.a.isInArray(x.ShapeType.character, this.options.particles.shape.type)) if (this.options.particles.shape.character instanceof Array) for (const t of this.options.particles.shape.character) yield n.a.loadFont(t);else {\n              const t = this.options.particles.shape.character;\n              yield n.a.loadFont(t);\n            }\n            if (n.a.isInArray(x.ShapeType.image, this.options.particles.shape.type)) if (this.options.particles.shape.image instanceof Array) for (const t of this.options.particles.shape.image) yield this.loadImageShape(t);else yield this.loadImageShape(this.options.particles.shape.image);\n            this.checkBeforeDraw();\n          }\n        });\n      }\n\n      loadImageShape(t) {\n        return V(this, void 0, void 0, function* () {\n          const e = t.src,\n                i = {\n            error: !1\n          };\n          i.type = e.substr(e.length - 3), yield this.loadImage(i, t), this.images.push(i);\n        });\n      }\n\n      init() {\n        this.retina.init(), this.canvas.init(), this.particles.init(), this.densityAutoParticles();\n      }\n\n      checkBeforeDraw() {\n        this.options.particles.shape.type === x.ShapeType.image && this.images.every(t => t.error) || (this.init(), this.play());\n      }\n\n    }\n  }, function (e, i) {\n    e.exports = t;\n  }, function (t, e) {\n    t.exports = function (t, e) {\n      return t === e || t != t && e != e;\n    };\n  }, function (t, e, i) {\n    var o = i(20),\n        n = i(34);\n\n    t.exports = function (t) {\n      if (!n(t)) return !1;\n      var e = o(t);\n      return \"[object Function]\" == e || \"[object GeneratorFunction]\" == e || \"[object AsyncFunction]\" == e || \"[object Proxy]\" == e;\n    };\n  }, function (t, e, i) {\n    (function (e) {\n      var i = \"object\" == typeof e && e && e.Object === Object && e;\n      t.exports = i;\n    }).call(this, i(59));\n  }, function (t, e) {\n    t.exports = function (t) {\n      var e = typeof t;\n      return null != t && (\"object\" == e || \"function\" == e);\n    };\n  }, function (t, e) {\n    var i = Function.prototype.toString;\n\n    t.exports = function (t) {\n      if (null != t) {\n        try {\n          return i.call(t);\n        } catch (t) {}\n\n        try {\n          return t + \"\";\n        } catch (t) {}\n      }\n\n      return \"\";\n    };\n  }, function (t, e, i) {\n    var o = i(65),\n        n = i(72),\n        s = i(74),\n        a = i(75),\n        r = i(76);\n\n    function c(t) {\n      var e = -1,\n          i = null == t ? 0 : t.length;\n\n      for (this.clear(); ++e < i;) {\n        var o = t[e];\n        this.set(o[0], o[1]);\n      }\n    }\n\n    c.prototype.clear = o, c.prototype.delete = n, c.prototype.get = s, c.prototype.has = a, c.prototype.set = r, t.exports = c;\n  }, function (t, e, i) {\n    var o = i(77),\n        n = i(80),\n        s = i(81);\n\n    t.exports = function (t, e, i, a, r, c) {\n      var l = 1 & i,\n          h = t.length,\n          d = e.length;\n      if (h != d && !(l && d > h)) return !1;\n      var u = c.get(t);\n      if (u && c.get(e)) return u == e;\n      var p = -1,\n          v = !0,\n          y = 2 & i ? new o() : void 0;\n\n      for (c.set(t, e), c.set(e, t); ++p < h;) {\n        var f = t[p],\n            m = e[p];\n        if (a) var g = l ? a(m, f, p, e, t, c) : a(f, m, p, t, e, c);\n\n        if (void 0 !== g) {\n          if (g) continue;\n          v = !1;\n          break;\n        }\n\n        if (y) {\n          if (!n(e, function (t, e) {\n            if (!s(y, e) && (f === t || r(f, t, i, a, c))) return y.push(e);\n          })) {\n            v = !1;\n            break;\n          }\n        } else if (f !== m && !r(f, m, i, a, c)) {\n          v = !1;\n          break;\n        }\n      }\n\n      return c.delete(t), c.delete(e), v;\n    };\n  }, function (t, e, i) {\n    (function (t) {\n      var o = i(13),\n          n = i(98),\n          s = e && !e.nodeType && e,\n          a = s && \"object\" == typeof t && t && !t.nodeType && t,\n          r = a && a.exports === s ? o.Buffer : void 0,\n          c = (r ? r.isBuffer : void 0) || n;\n      t.exports = c;\n    }).call(this, i(39)(t));\n  }, function (t, e) {\n    t.exports = function (t) {\n      return t.webpackPolyfill || (t.deprecate = function () {}, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, \"loaded\", {\n        enumerable: !0,\n        get: function () {\n          return t.l;\n        }\n      }), Object.defineProperty(t, \"id\", {\n        enumerable: !0,\n        get: function () {\n          return t.i;\n        }\n      }), t.webpackPolyfill = 1), t;\n    };\n  }, function (t, e, i) {\n    var o = i(100),\n        n = i(101),\n        s = i(102),\n        a = s && s.isTypedArray,\n        r = a ? n(a) : o;\n    t.exports = r;\n  }, function (t, e) {\n    t.exports = function (t) {\n      return \"number\" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991;\n    };\n  }, function (t, e, i) {\n    \"use strict\";\n\n    function o(t) {\n      for (var i in t) e.hasOwnProperty(i) || (e[i] = t[i]);\n    }\n\n    var n = this && this.__importDefault || function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    };\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var s = n(i(43));\n    e.Particles = s.default, o(i(14)), o(i(9)), o(i(4)), o(i(10)), o(i(24)), o(i(5)), o(i(12)), o(i(11)), o(i(3)), o(i(7)), o(i(17)), o(i(6)), e.default = s.default;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    function o(t) {\n      return (o = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n\n    function n(t, e) {\n      for (var i = 0; i < e.length; i++) {\n        var o = e[i];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);\n      }\n    }\n\n    function s(t, e, i) {\n      return (s = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, i) {\n        var o = function (t, e) {\n          for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = l(t)););\n\n          return t;\n        }(t, e);\n\n        if (o) {\n          var n = Object.getOwnPropertyDescriptor(o, e);\n          return n.get ? n.get.call(i) : n.value;\n        }\n      })(t, e, i || t);\n    }\n\n    function a(t, e) {\n      return !e || \"object\" !== o(e) && \"function\" != typeof e ? r(t) : e;\n    }\n\n    function r(t) {\n      if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return t;\n    }\n\n    function c() {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n\n    function l(t) {\n      return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n        return t.__proto__ || Object.getPrototypeOf(t);\n      })(t);\n    }\n\n    function h(t, e) {\n      return (h = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    var d = this && this.__importStar || function (t) {\n      if (t && t.__esModule) return t;\n      var e = {};\n      if (null != t) for (var i in t) Object.hasOwnProperty.call(t, i) && (e[i] = t[i]);\n      return e.default = t, e;\n    },\n        u = this && this.__importDefault || function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    };\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    var p = d(i(30)),\n        v = i(30),\n        y = u(i(44)),\n        f = i(29),\n        m = i(113),\n        g = i(28),\n        b = i(114),\n        w = function (t) {\n      !function (t, e) {\n        if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n        t.prototype = Object.create(e && e.prototype, {\n          constructor: {\n            value: t,\n            writable: !0,\n            configurable: !0\n          }\n        }), e && h(t, e);\n      }(v, t);\n      var e,\n          i,\n          o,\n          d,\n          u = (e = v, function () {\n        var t,\n            i = l(e);\n\n        if (c()) {\n          var o = l(this).constructor;\n          t = Reflect.construct(i, arguments, o);\n        } else t = i.apply(this, arguments);\n\n        return a(this, t);\n      });\n\n      function v(t) {\n        var e;\n        return function (t, e) {\n          if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, v), (e = u.call(this, t)).state = {\n          canvas: void 0,\n          library: void 0\n        }, e.loadCanvas = e.loadCanvas.bind(r(e)), e;\n      }\n\n      return i = v, (o = [{\n        key: \"buildParticlesLibrary\",\n        value: function (t, e) {\n          try {\n            if (void 0 === window) return null;\n          } catch (t) {\n            return null;\n          }\n\n          var i = new g.Options();\n          return i.load(m.defaultParams), i.load(e), b.tsParticles.dom(), new f.Container(t, i);\n        }\n      }, {\n        key: \"refresh\",\n        value: function (t) {\n          var e = this,\n              i = this.state.canvas;\n          i && (this.destroy(), this.setState({\n            library: this.buildParticlesLibrary(t.id, t.params)\n          }, function () {\n            e.loadCanvas(i);\n          }));\n        }\n      }, {\n        key: \"destroy\",\n        value: function () {\n          this.state.library && this.state.library.destroy();\n        }\n      }, {\n        key: \"loadCanvas\",\n        value: function (t) {\n          var e = this;\n          t && this.setState({\n            canvas: t\n          }, function () {\n            var i = e.state.library;\n            i && (i.canvas.loadCanvas(t), i.start());\n          });\n        }\n      }, {\n        key: \"shouldComponentUpdate\",\n        value: function (t) {\n          return !y.default(t, this.props);\n        }\n      }, {\n        key: \"componentDidUpdate\",\n        value: function () {\n          this.refresh(this.props);\n        }\n      }, {\n        key: \"forceUpdate\",\n        value: function () {\n          this.refresh(this.props), s(l(v.prototype), \"forceUpdate\", this).call(this);\n        }\n      }, {\n        key: \"componentDidMount\",\n        value: function () {\n          this.setState({\n            library: this.buildParticlesLibrary(this.props.id, this.props.params)\n          });\n        }\n      }, {\n        key: \"componentWillUnmount\",\n        value: function () {\n          this.destroy(), this.setState({\n            library: void 0\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function () {\n          var t = this.props,\n              e = t.width,\n              i = t.height,\n              o = t.className,\n              n = t.canvasClassName,\n              s = t.id;\n          return p.createElement(\"div\", {\n            className: o,\n            id: s\n          }, p.createElement(\"canvas\", {\n            ref: this.loadCanvas,\n            className: n,\n            style: Object.assign(Object.assign({}, this.props.style), {\n              width: e,\n              height: i\n            })\n          }));\n        }\n      }]) && n(i.prototype, o), d && n(i, d), v;\n    }(v.Component);\n\n    e.default = w, w.defaultProps = {\n      width: \"100%\",\n      height: \"100%\",\n      params: m.defaultParams,\n      style: {},\n      id: \"tsparticles\"\n    };\n  }, function (t, e, i) {\n    var o = i(45);\n\n    t.exports = function (t, e) {\n      return o(t, e);\n    };\n  }, function (t, e, i) {\n    var o = i(46),\n        n = i(23);\n\n    t.exports = function t(e, i, s, a, r) {\n      return e === i || (null == e || null == i || !n(e) && !n(i) ? e != e && i != i : o(e, i, s, a, t, r));\n    };\n  }, function (t, e, i) {\n    var o = i(47),\n        n = i(37),\n        s = i(82),\n        a = i(86),\n        r = i(108),\n        c = i(27),\n        l = i(38),\n        h = i(40),\n        d = \"[object Object]\",\n        u = Object.prototype.hasOwnProperty;\n\n    t.exports = function (t, e, i, p, v, y) {\n      var f = c(t),\n          m = c(e),\n          g = f ? \"[object Array]\" : r(t),\n          b = m ? \"[object Array]\" : r(e),\n          w = (g = \"[object Arguments]\" == g ? d : g) == d,\n          x = (b = \"[object Arguments]\" == b ? d : b) == d,\n          k = g == b;\n\n      if (k && l(t)) {\n        if (!l(e)) return !1;\n        f = !0, w = !1;\n      }\n\n      if (k && !w) return y || (y = new o()), f || h(t) ? n(t, e, i, p, v, y) : s(t, e, g, i, p, v, y);\n\n      if (!(1 & i)) {\n        var P = w && u.call(t, \"__wrapped__\"),\n            _ = x && u.call(e, \"__wrapped__\");\n\n        if (P || _) {\n          var M = P ? t.value() : t,\n              S = _ ? e.value() : e;\n          return y || (y = new o()), v(M, S, i, p, y);\n        }\n      }\n\n      return !!k && (y || (y = new o()), a(t, e, i, p, v, y));\n    };\n  }, function (t, e, i) {\n    var o = i(18),\n        n = i(53),\n        s = i(54),\n        a = i(55),\n        r = i(56),\n        c = i(57);\n\n    function l(t) {\n      var e = this.__data__ = new o(t);\n      this.size = e.size;\n    }\n\n    l.prototype.clear = n, l.prototype.delete = s, l.prototype.get = a, l.prototype.has = r, l.prototype.set = c, t.exports = l;\n  }, function (t, e) {\n    t.exports = function () {\n      this.__data__ = [], this.size = 0;\n    };\n  }, function (t, e, i) {\n    var o = i(19),\n        n = Array.prototype.splice;\n\n    t.exports = function (t) {\n      var e = this.__data__,\n          i = o(e, t);\n      return !(i < 0) && (i == e.length - 1 ? e.pop() : n.call(e, i, 1), --this.size, !0);\n    };\n  }, function (t, e, i) {\n    var o = i(19);\n\n    t.exports = function (t) {\n      var e = this.__data__,\n          i = o(e, t);\n      return i < 0 ? void 0 : e[i][1];\n    };\n  }, function (t, e, i) {\n    var o = i(19);\n\n    t.exports = function (t) {\n      return o(this.__data__, t) > -1;\n    };\n  }, function (t, e, i) {\n    var o = i(19);\n\n    t.exports = function (t, e) {\n      var i = this.__data__,\n          n = o(i, t);\n      return n < 0 ? (++this.size, i.push([t, e])) : i[n][1] = e, this;\n    };\n  }, function (t, e, i) {\n    var o = i(18);\n\n    t.exports = function () {\n      this.__data__ = new o(), this.size = 0;\n    };\n  }, function (t, e) {\n    t.exports = function (t) {\n      var e = this.__data__,\n          i = e.delete(t);\n      return this.size = e.size, i;\n    };\n  }, function (t, e) {\n    t.exports = function (t) {\n      return this.__data__.get(t);\n    };\n  }, function (t, e) {\n    t.exports = function (t) {\n      return this.__data__.has(t);\n    };\n  }, function (t, e, i) {\n    var o = i(18),\n        n = i(25),\n        s = i(36);\n\n    t.exports = function (t, e) {\n      var i = this.__data__;\n\n      if (i instanceof o) {\n        var a = i.__data__;\n        if (!n || a.length < 199) return a.push([t, e]), this.size = ++i.size, this;\n        i = this.__data__ = new s(a);\n      }\n\n      return i.set(t, e), this.size = i.size, this;\n    };\n  }, function (t, e, i) {\n    var o = i(32),\n        n = i(62),\n        s = i(34),\n        a = i(35),\n        r = /^\\[object .+?Constructor\\]$/,\n        c = Function.prototype,\n        l = Object.prototype,\n        h = c.toString,\n        d = l.hasOwnProperty,\n        u = RegExp(\"^\" + h.call(d).replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n\n    t.exports = function (t) {\n      return !(!s(t) || n(t)) && (o(t) ? u : r).test(a(t));\n    };\n  }, function (t, e) {\n    var i;\n\n    i = function () {\n      return this;\n    }();\n\n    try {\n      i = i || new Function(\"return this\")();\n    } catch (t) {\n      \"object\" == typeof window && (i = window);\n    }\n\n    t.exports = i;\n  }, function (t, e, i) {\n    var o = i(26),\n        n = Object.prototype,\n        s = n.hasOwnProperty,\n        a = n.toString,\n        r = o ? o.toStringTag : void 0;\n\n    t.exports = function (t) {\n      var e = s.call(t, r),\n          i = t[r];\n\n      try {\n        t[r] = void 0;\n        var o = !0;\n      } catch (t) {}\n\n      var n = a.call(t);\n      return o && (e ? t[r] = i : delete t[r]), n;\n    };\n  }, function (t, e) {\n    var i = Object.prototype.toString;\n\n    t.exports = function (t) {\n      return i.call(t);\n    };\n  }, function (t, e, i) {\n    var o,\n        n = i(63),\n        s = (o = /[^.]+$/.exec(n && n.keys && n.keys.IE_PROTO || \"\")) ? \"Symbol(src)_1.\" + o : \"\";\n\n    t.exports = function (t) {\n      return !!s && s in t;\n    };\n  }, function (t, e, i) {\n    var o = i(13)[\"__core-js_shared__\"];\n    t.exports = o;\n  }, function (t, e) {\n    t.exports = function (t, e) {\n      return null == t ? void 0 : t[e];\n    };\n  }, function (t, e, i) {\n    var o = i(66),\n        n = i(18),\n        s = i(25);\n\n    t.exports = function () {\n      this.size = 0, this.__data__ = {\n        hash: new o(),\n        map: new (s || n)(),\n        string: new o()\n      };\n    };\n  }, function (t, e, i) {\n    var o = i(67),\n        n = i(68),\n        s = i(69),\n        a = i(70),\n        r = i(71);\n\n    function c(t) {\n      var e = -1,\n          i = null == t ? 0 : t.length;\n\n      for (this.clear(); ++e < i;) {\n        var o = t[e];\n        this.set(o[0], o[1]);\n      }\n    }\n\n    c.prototype.clear = o, c.prototype.delete = n, c.prototype.get = s, c.prototype.has = a, c.prototype.set = r, t.exports = c;\n  }, function (t, e, i) {\n    var o = i(21);\n\n    t.exports = function () {\n      this.__data__ = o ? o(null) : {}, this.size = 0;\n    };\n  }, function (t, e) {\n    t.exports = function (t) {\n      var e = this.has(t) && delete this.__data__[t];\n      return this.size -= e ? 1 : 0, e;\n    };\n  }, function (t, e, i) {\n    var o = i(21),\n        n = Object.prototype.hasOwnProperty;\n\n    t.exports = function (t) {\n      var e = this.__data__;\n\n      if (o) {\n        var i = e[t];\n        return \"__lodash_hash_undefined__\" === i ? void 0 : i;\n      }\n\n      return n.call(e, t) ? e[t] : void 0;\n    };\n  }, function (t, e, i) {\n    var o = i(21),\n        n = Object.prototype.hasOwnProperty;\n\n    t.exports = function (t) {\n      var e = this.__data__;\n      return o ? void 0 !== e[t] : n.call(e, t);\n    };\n  }, function (t, e, i) {\n    var o = i(21);\n\n    t.exports = function (t, e) {\n      var i = this.__data__;\n      return this.size += this.has(t) ? 0 : 1, i[t] = o && void 0 === e ? \"__lodash_hash_undefined__\" : e, this;\n    };\n  }, function (t, e, i) {\n    var o = i(22);\n\n    t.exports = function (t) {\n      var e = o(this, t).delete(t);\n      return this.size -= e ? 1 : 0, e;\n    };\n  }, function (t, e) {\n    t.exports = function (t) {\n      var e = typeof t;\n      return \"string\" == e || \"number\" == e || \"symbol\" == e || \"boolean\" == e ? \"__proto__\" !== t : null === t;\n    };\n  }, function (t, e, i) {\n    var o = i(22);\n\n    t.exports = function (t) {\n      return o(this, t).get(t);\n    };\n  }, function (t, e, i) {\n    var o = i(22);\n\n    t.exports = function (t) {\n      return o(this, t).has(t);\n    };\n  }, function (t, e, i) {\n    var o = i(22);\n\n    t.exports = function (t, e) {\n      var i = o(this, t),\n          n = i.size;\n      return i.set(t, e), this.size += i.size == n ? 0 : 1, this;\n    };\n  }, function (t, e, i) {\n    var o = i(36),\n        n = i(78),\n        s = i(79);\n\n    function a(t) {\n      var e = -1,\n          i = null == t ? 0 : t.length;\n\n      for (this.__data__ = new o(); ++e < i;) this.add(t[e]);\n    }\n\n    a.prototype.add = a.prototype.push = n, a.prototype.has = s, t.exports = a;\n  }, function (t, e) {\n    t.exports = function (t) {\n      return this.__data__.set(t, \"__lodash_hash_undefined__\"), this;\n    };\n  }, function (t, e) {\n    t.exports = function (t) {\n      return this.__data__.has(t);\n    };\n  }, function (t, e) {\n    t.exports = function (t, e) {\n      for (var i = -1, o = null == t ? 0 : t.length; ++i < o;) if (e(t[i], i, t)) return !0;\n\n      return !1;\n    };\n  }, function (t, e) {\n    t.exports = function (t, e) {\n      return t.has(e);\n    };\n  }, function (t, e, i) {\n    var o = i(26),\n        n = i(83),\n        s = i(31),\n        a = i(37),\n        r = i(84),\n        c = i(85),\n        l = o ? o.prototype : void 0,\n        h = l ? l.valueOf : void 0;\n\n    t.exports = function (t, e, i, o, l, d, u) {\n      switch (i) {\n        case \"[object DataView]\":\n          if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;\n          t = t.buffer, e = e.buffer;\n\n        case \"[object ArrayBuffer]\":\n          return !(t.byteLength != e.byteLength || !d(new n(t), new n(e)));\n\n        case \"[object Boolean]\":\n        case \"[object Date]\":\n        case \"[object Number]\":\n          return s(+t, +e);\n\n        case \"[object Error]\":\n          return t.name == e.name && t.message == e.message;\n\n        case \"[object RegExp]\":\n        case \"[object String]\":\n          return t == e + \"\";\n\n        case \"[object Map]\":\n          var p = r;\n\n        case \"[object Set]\":\n          var v = 1 & o;\n          if (p || (p = c), t.size != e.size && !v) return !1;\n          var y = u.get(t);\n          if (y) return y == e;\n          o |= 2, u.set(t, e);\n          var f = a(p(t), p(e), o, l, d, u);\n          return u.delete(t), f;\n\n        case \"[object Symbol]\":\n          if (h) return h.call(t) == h.call(e);\n      }\n\n      return !1;\n    };\n  }, function (t, e, i) {\n    var o = i(13).Uint8Array;\n    t.exports = o;\n  }, function (t, e) {\n    t.exports = function (t) {\n      var e = -1,\n          i = Array(t.size);\n      return t.forEach(function (t, o) {\n        i[++e] = [o, t];\n      }), i;\n    };\n  }, function (t, e) {\n    t.exports = function (t) {\n      var e = -1,\n          i = Array(t.size);\n      return t.forEach(function (t) {\n        i[++e] = t;\n      }), i;\n    };\n  }, function (t, e, i) {\n    var o = i(87),\n        n = Object.prototype.hasOwnProperty;\n\n    t.exports = function (t, e, i, s, a, r) {\n      var c = 1 & i,\n          l = o(t),\n          h = l.length;\n      if (h != o(e).length && !c) return !1;\n\n      for (var d = h; d--;) {\n        var u = l[d];\n        if (!(c ? u in e : n.call(e, u))) return !1;\n      }\n\n      var p = r.get(t);\n      if (p && r.get(e)) return p == e;\n      var v = !0;\n      r.set(t, e), r.set(e, t);\n\n      for (var y = c; ++d < h;) {\n        var f = t[u = l[d]],\n            m = e[u];\n        if (s) var g = c ? s(m, f, u, e, t, r) : s(f, m, u, t, e, r);\n\n        if (!(void 0 === g ? f === m || a(f, m, i, s, r) : g)) {\n          v = !1;\n          break;\n        }\n\n        y || (y = \"constructor\" == u);\n      }\n\n      if (v && !y) {\n        var b = t.constructor,\n            w = e.constructor;\n        b == w || !(\"constructor\" in t) || !(\"constructor\" in e) || \"function\" == typeof b && b instanceof b && \"function\" == typeof w && w instanceof w || (v = !1);\n      }\n\n      return r.delete(t), r.delete(e), v;\n    };\n  }, function (t, e, i) {\n    var o = i(88),\n        n = i(90),\n        s = i(93);\n\n    t.exports = function (t) {\n      return o(t, s, n);\n    };\n  }, function (t, e, i) {\n    var o = i(89),\n        n = i(27);\n\n    t.exports = function (t, e, i) {\n      var s = e(t);\n      return n(t) ? s : o(s, i(t));\n    };\n  }, function (t, e) {\n    t.exports = function (t, e) {\n      for (var i = -1, o = e.length, n = t.length; ++i < o;) t[n + i] = e[i];\n\n      return t;\n    };\n  }, function (t, e, i) {\n    var o = i(91),\n        n = i(92),\n        s = Object.prototype.propertyIsEnumerable,\n        a = Object.getOwnPropertySymbols,\n        r = a ? function (t) {\n      return null == t ? [] : (t = Object(t), o(a(t), function (e) {\n        return s.call(t, e);\n      }));\n    } : n;\n    t.exports = r;\n  }, function (t, e) {\n    t.exports = function (t, e) {\n      for (var i = -1, o = null == t ? 0 : t.length, n = 0, s = []; ++i < o;) {\n        var a = t[i];\n        e(a, i, t) && (s[n++] = a);\n      }\n\n      return s;\n    };\n  }, function (t, e) {\n    t.exports = function () {\n      return [];\n    };\n  }, function (t, e, i) {\n    var o = i(94),\n        n = i(103),\n        s = i(107);\n\n    t.exports = function (t) {\n      return s(t) ? o(t) : n(t);\n    };\n  }, function (t, e, i) {\n    var o = i(95),\n        n = i(96),\n        s = i(27),\n        a = i(38),\n        r = i(99),\n        c = i(40),\n        l = Object.prototype.hasOwnProperty;\n\n    t.exports = function (t, e) {\n      var i = s(t),\n          h = !i && n(t),\n          d = !i && !h && a(t),\n          u = !i && !h && !d && c(t),\n          p = i || h || d || u,\n          v = p ? o(t.length, String) : [],\n          y = v.length;\n\n      for (var f in t) !e && !l.call(t, f) || p && (\"length\" == f || d && (\"offset\" == f || \"parent\" == f) || u && (\"buffer\" == f || \"byteLength\" == f || \"byteOffset\" == f) || r(f, y)) || v.push(f);\n\n      return v;\n    };\n  }, function (t, e) {\n    t.exports = function (t, e) {\n      for (var i = -1, o = Array(t); ++i < t;) o[i] = e(i);\n\n      return o;\n    };\n  }, function (t, e, i) {\n    var o = i(97),\n        n = i(23),\n        s = Object.prototype,\n        a = s.hasOwnProperty,\n        r = s.propertyIsEnumerable,\n        c = o(function () {\n      return arguments;\n    }()) ? o : function (t) {\n      return n(t) && a.call(t, \"callee\") && !r.call(t, \"callee\");\n    };\n    t.exports = c;\n  }, function (t, e, i) {\n    var o = i(20),\n        n = i(23);\n\n    t.exports = function (t) {\n      return n(t) && \"[object Arguments]\" == o(t);\n    };\n  }, function (t, e) {\n    t.exports = function () {\n      return !1;\n    };\n  }, function (t, e) {\n    var i = /^(?:0|[1-9]\\d*)$/;\n\n    t.exports = function (t, e) {\n      var o = typeof t;\n      return !!(e = null == e ? 9007199254740991 : e) && (\"number\" == o || \"symbol\" != o && i.test(t)) && t > -1 && t % 1 == 0 && t < e;\n    };\n  }, function (t, e, i) {\n    var o = i(20),\n        n = i(41),\n        s = i(23),\n        a = {};\n    a[\"[object Float32Array]\"] = a[\"[object Float64Array]\"] = a[\"[object Int8Array]\"] = a[\"[object Int16Array]\"] = a[\"[object Int32Array]\"] = a[\"[object Uint8Array]\"] = a[\"[object Uint8ClampedArray]\"] = a[\"[object Uint16Array]\"] = a[\"[object Uint32Array]\"] = !0, a[\"[object Arguments]\"] = a[\"[object Array]\"] = a[\"[object ArrayBuffer]\"] = a[\"[object Boolean]\"] = a[\"[object DataView]\"] = a[\"[object Date]\"] = a[\"[object Error]\"] = a[\"[object Function]\"] = a[\"[object Map]\"] = a[\"[object Number]\"] = a[\"[object Object]\"] = a[\"[object RegExp]\"] = a[\"[object Set]\"] = a[\"[object String]\"] = a[\"[object WeakMap]\"] = !1, t.exports = function (t) {\n      return s(t) && n(t.length) && !!a[o(t)];\n    };\n  }, function (t, e) {\n    t.exports = function (t) {\n      return function (e) {\n        return t(e);\n      };\n    };\n  }, function (t, e, i) {\n    (function (t) {\n      var o = i(33),\n          n = e && !e.nodeType && e,\n          s = n && \"object\" == typeof t && t && !t.nodeType && t,\n          a = s && s.exports === n && o.process,\n          r = function () {\n        try {\n          var t = s && s.require && s.require(\"util\").types;\n\n          return t || a && a.binding && a.binding(\"util\");\n        } catch (t) {}\n      }();\n\n      t.exports = r;\n    }).call(this, i(39)(t));\n  }, function (t, e, i) {\n    var o = i(104),\n        n = i(105),\n        s = Object.prototype.hasOwnProperty;\n\n    t.exports = function (t) {\n      if (!o(t)) return n(t);\n      var e = [];\n\n      for (var i in Object(t)) s.call(t, i) && \"constructor\" != i && e.push(i);\n\n      return e;\n    };\n  }, function (t, e) {\n    var i = Object.prototype;\n\n    t.exports = function (t) {\n      var e = t && t.constructor;\n      return t === (\"function\" == typeof e && e.prototype || i);\n    };\n  }, function (t, e, i) {\n    var o = i(106)(Object.keys, Object);\n    t.exports = o;\n  }, function (t, e) {\n    t.exports = function (t, e) {\n      return function (i) {\n        return t(e(i));\n      };\n    };\n  }, function (t, e, i) {\n    var o = i(32),\n        n = i(41);\n\n    t.exports = function (t) {\n      return null != t && n(t.length) && !o(t);\n    };\n  }, function (t, e, i) {\n    var o = i(109),\n        n = i(25),\n        s = i(110),\n        a = i(111),\n        r = i(112),\n        c = i(20),\n        l = i(35),\n        h = l(o),\n        d = l(n),\n        u = l(s),\n        p = l(a),\n        v = l(r),\n        y = c;\n    (o && \"[object DataView]\" != y(new o(new ArrayBuffer(1))) || n && \"[object Map]\" != y(new n()) || s && \"[object Promise]\" != y(s.resolve()) || a && \"[object Set]\" != y(new a()) || r && \"[object WeakMap]\" != y(new r())) && (y = function (t) {\n      var e = c(t),\n          i = \"[object Object]\" == e ? t.constructor : void 0,\n          o = i ? l(i) : \"\";\n      if (o) switch (o) {\n        case h:\n          return \"[object DataView]\";\n\n        case d:\n          return \"[object Map]\";\n\n        case u:\n          return \"[object Promise]\";\n\n        case p:\n          return \"[object Set]\";\n\n        case v:\n          return \"[object WeakMap]\";\n      }\n      return e;\n    }), t.exports = y;\n  }, function (t, e, i) {\n    var o = i(15)(i(13), \"DataView\");\n    t.exports = o;\n  }, function (t, e, i) {\n    var o = i(15)(i(13), \"Promise\");\n    t.exports = o;\n  }, function (t, e, i) {\n    var o = i(15)(i(13), \"Set\");\n    t.exports = o;\n  }, function (t, e, i) {\n    var o = i(15)(i(13), \"WeakMap\");\n    t.exports = o;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var o = i(3),\n        n = i(5),\n        s = i(10),\n        a = i(24),\n        r = i(6),\n        c = i(7),\n        l = i(14),\n        h = i(4),\n        d = i(9);\n    e.defaultParams = {\n      particles: {\n        number: {\n          value: 40,\n          max: -1,\n          density: {\n            enable: !1,\n            value_area: 1200\n          }\n        },\n        color: {\n          value: \"#FFF\"\n        },\n        shape: {\n          type: o.ShapeType.circle,\n          stroke: {\n            width: 0,\n            color: \"#000000\"\n          },\n          polygon: {\n            nb_sides: 5\n          },\n          image: {\n            src: \"\",\n            width: 100,\n            height: 100\n          }\n        },\n        opacity: {\n          value: .5,\n          random: !1,\n          anim: {\n            enable: !0,\n            speed: 1,\n            opacity_min: .1,\n            sync: !1\n          }\n        },\n        size: {\n          value: 1,\n          random: !1,\n          anim: {\n            enable: !1,\n            speed: 40,\n            size_min: 0,\n            sync: !1\n          }\n        },\n        line_linked: {\n          enable: !0,\n          distance: 150,\n          color: \"#FFF\",\n          opacity: .6,\n          width: 1,\n          shadow: {\n            enable: !1,\n            blur: 5,\n            color: \"lime\"\n          }\n        },\n        move: {\n          enable: !0,\n          speed: 3,\n          direction: d.MoveDirection.none,\n          random: !1,\n          straight: !1,\n          out_mode: h.OutMode.bounce,\n          bounce: !0,\n          attract: {\n            enable: !1,\n            rotateX: 3e3,\n            rotateY: 3e3\n          }\n        }\n      },\n      interactivity: {\n        detectsOn: l.InteractivityDetect.canvas,\n        events: {\n          onHover: {\n            enable: !1,\n            mode: r.HoverMode.grab\n          },\n          onClick: {\n            enable: !1,\n            mode: c.ClickMode.repulse\n          },\n          resize: !0\n        },\n        modes: {\n          grab: {\n            distance: 180,\n            line_linked: {\n              opacity: .35\n            }\n          },\n          bubble: {\n            distance: 200,\n            size: 80,\n            duration: .4\n          },\n          repulse: {\n            distance: 100,\n            duration: 5\n          },\n          push: {\n            particles_nb: 4\n          },\n          remove: {\n            particles_nb: 2\n          }\n        }\n      },\n      retina_detect: !0,\n      fps_limit: 999,\n      polygon: {\n        enable: !1,\n        scale: 1,\n        type: n.PolygonMaskType.inline,\n        inline: {\n          arrangement: s.PolygonMaskInlineArrangement.onePerPoint\n        },\n        draw: {\n          enable: !1,\n          stroke: {\n            width: .5,\n            color: \"rgba(255, 255, 255, .1)\"\n          }\n        },\n        move: {\n          radius: 10,\n          type: a.PolygonMaskMoveType.path\n        },\n        url: \"\"\n      }\n    };\n  }, function (t, e, i) {\n    \"use strict\";\n\n    i.r(e), i.d(e, \"tsParticles\", function () {\n      return k;\n    });\n\n    var o = i(29),\n        n = i(2),\n        s = i(0),\n        a = function (t, e, i, o) {\n      return new (i || (i = Promise))(function (n, s) {\n        function a(t) {\n          try {\n            c(o.next(t));\n          } catch (t) {\n            s(t);\n          }\n        }\n\n        function r(t) {\n          try {\n            c(o.throw(t));\n          } catch (t) {\n            s(t);\n          }\n        }\n\n        function c(t) {\n          var e;\n          t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) {\n            t(e);\n          })).then(a, r);\n        }\n\n        c((o = o.apply(t, e || [])).next());\n      });\n    };\n\n    let r = [];\n\n    class c {\n      static dom() {\n        return r || (r = []), r;\n      }\n\n      static domItem(t) {\n        const e = c.dom(),\n              i = e[t];\n        if (i && !i.destroyed) return i;\n        e.splice(t, 1);\n      }\n\n      static loadFromArray(t, e, i) {\n        return a(this, void 0, void 0, function* () {\n          return c.load(t, s.a.itemFromArray(e, i));\n        });\n      }\n\n      static setFromArray(t, e, i, o) {\n        return a(this, void 0, void 0, function* () {\n          return c.set(t, e, s.a.itemFromArray(i, o));\n        });\n      }\n\n      static load(t, e) {\n        return a(this, void 0, void 0, function* () {\n          const i = document.getElementById(t);\n          if (i) return this.set(t, i, e);\n        });\n      }\n\n      static set(t, e, i) {\n        return a(this, void 0, void 0, function* () {\n          const s = c.dom(),\n                a = s.findIndex(e => e.id === t);\n\n          if (a >= 0) {\n            const t = this.domItem(a);\n            t && !t.destroyed && (t.destroy(), s.splice(a, 1));\n          }\n\n          let r, l;\n          if (\"canvas\" === e.tagName) r = e, l = !1;else {\n            const t = e.getElementsByTagName(\"canvas\");\n            t.length ? (r = t[0], r.className || (r.className = n.a.canvasClass), l = !1) : (l = !0, r = document.createElement(\"canvas\"), r.className = n.a.canvasClass, r.style.width = \"100%\", r.style.height = \"100%\", e.appendChild(r));\n          }\n          const h = new o.Container(t, i);\n          return a >= 0 ? s.splice(a, 0, h) : s.push(h), h.canvas.loadCanvas(r, l), yield h.start(), h;\n        });\n      }\n\n      static loadJSON(t, e) {\n        return a(this, void 0, void 0, function* () {\n          const i = yield fetch(e);\n\n          if (i.ok) {\n            const e = yield i.json();\n            return e instanceof Array ? c.loadFromArray(t, e) : c.load(t, e);\n          }\n\n          console.error(\"Error tsParticles - fetch status: \".concat(i.status)), console.error(\"Error tsParticles - File config not found\");\n        });\n      }\n\n      static setJSON(t, e, i) {\n        return a(this, void 0, void 0, function* () {\n          const o = yield fetch(i);\n\n          if (o.ok) {\n            const i = yield o.json();\n            return i instanceof Array ? c.setFromArray(t, e, i) : c.set(t, e, i);\n          }\n\n          console.error(\"Error tsParticles - fetch status: \".concat(o.status)), console.error(\"Error tsParticles - File config not found\");\n        });\n      }\n\n      static setOnClickHandler(t) {\n        const e = c.dom();\n        if (0 === e.length) throw new Error(\"Can only set click handlers after calling tsParticles.load() or tsParticles.loadJSON()\");\n\n        for (const i of e) {\n          const e = i.interactivity.element;\n          e && e.addEventListener(\"click\", t);\n        }\n      }\n\n    }\n\n    var l = i(8),\n        h = i(3);\n\n    class d {\n      draw(t, e, i, o) {\n        t.moveTo(0, -i / 2), t.lineTo(0, i / 2);\n      }\n\n    }\n\n    class u {\n      draw(t, e, i, o) {\n        t.arc(0, 0, i, 0, 2 * Math.PI, !1);\n      }\n\n    }\n\n    class p {\n      draw(t, e, i, o) {\n        t.rect(-i, -i, 2 * i, 2 * i);\n      }\n\n    }\n\n    class v {\n      draw(t, e, i, o) {\n        const n = this.getCenter(e, i),\n              s = this.getSidesData(e, i),\n              a = s.count.numerator * s.count.denominator,\n              r = s.count.numerator / s.count.denominator,\n              c = 180 * (r - 2) / r,\n              l = Math.PI - Math.PI * c / 180;\n\n        if (t) {\n          t.beginPath(), t.translate(n.x, n.y), t.moveTo(0, 0);\n\n          for (let e = 0; e < a; e++) t.lineTo(s.length, 0), t.translate(s.length, 0), t.rotate(l);\n        }\n      }\n\n    }\n\n    class y extends v {\n      getSidesData(t, e) {\n        return {\n          count: {\n            denominator: 2,\n            numerator: 3\n          },\n          length: 2 * e\n        };\n      }\n\n      getCenter(t, e) {\n        return {\n          x: -e,\n          y: e / 1.66\n        };\n      }\n\n    }\n\n    class f extends v {\n      getSidesData(t, e) {\n        var i, o;\n        const n = null !== (o = null === (i = t.polygon) || void 0 === i ? void 0 : i.sides) && void 0 !== o ? o : 5;\n        return {\n          count: {\n            denominator: 2,\n            numerator: n\n          },\n          length: 2 * e * 2.66 / (n / 3)\n        };\n      }\n\n      getCenter(t, e) {\n        var i, o;\n        return {\n          x: 2 * -e / ((null !== (o = null === (i = t.polygon) || void 0 === i ? void 0 : i.sides) && void 0 !== o ? o : 5) / 4),\n          y: -e / 1.52\n        };\n      }\n\n    }\n\n    class m extends v {\n      getSidesData(t, e) {\n        var i, o;\n        const n = null !== (o = null === (i = t.polygon) || void 0 === i ? void 0 : i.sides) && void 0 !== o ? o : 5;\n        return {\n          count: {\n            denominator: 1,\n            numerator: n\n          },\n          length: 2.66 * e / (n / 3)\n        };\n      }\n\n      getCenter(t, e) {\n        var i, o;\n        return {\n          x: -e / ((null !== (o = null === (i = t.polygon) || void 0 === i ? void 0 : i.sides) && void 0 !== o ? o : 5) / 3.5),\n          y: -e / .76\n        };\n      }\n\n    }\n\n    class g {\n      draw(t, e, i, o) {\n        const n = e.text,\n              s = e.character;\n        if (void 0 === n || void 0 === s) return;\n        const a = s.style,\n              r = s.weight,\n              c = 2 * Math.round(i),\n              l = s.font,\n              h = s.fill;\n        t.font = \"\".concat(a, \" \").concat(r, \" \").concat(c, \"px \\\"\").concat(l, \"\\\"\");\n        const d = {\n          x: -i / 2,\n          y: i / 2\n        };\n        h ? t.fillText(n, d.x, d.y) : t.strokeText(n, d.x, d.y);\n      }\n\n    }\n\n    class b {\n      draw(t, e, i, o) {\n        var n;\n        if (!t) return;\n        const s = null === (n = e.image) || void 0 === n ? void 0 : n.data.obj;\n        if (!s) return;\n        let a = 1;\n        e.image && (a = e.image.ratio);\n        const r = {\n          x: -i,\n          y: -i\n        };\n        t.globalAlpha = o, t.drawImage(s, r.x, r.y, 2 * i, 2 * i / a), t.globalAlpha = 1;\n      }\n\n    }\n\n    var w = i(16),\n        x = function (t, e, i, o) {\n      return new (i || (i = Promise))(function (n, s) {\n        function a(t) {\n          try {\n            c(o.next(t));\n          } catch (t) {\n            s(t);\n          }\n        }\n\n        function r(t) {\n          try {\n            c(o.throw(t));\n          } catch (t) {\n            s(t);\n          }\n        }\n\n        function c(t) {\n          var e;\n          t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) {\n            t(e);\n          })).then(a, r);\n        }\n\n        c((o = o.apply(t, e || [])).next());\n      });\n    };\n\n    const k = new class {\n      constructor() {\n        this.initialized = !1, \"undefined\" != typeof window && window && (window.customRequestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || (t => window.setTimeout(t, 1e3 / 60)), window.customCancelRequestAnimationFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout);\n        const t = new p(),\n              e = new g();\n        l.a.addShapeDrawer(h.ShapeType.line, new d()), l.a.addShapeDrawer(h.ShapeType.circle, new u()), l.a.addShapeDrawer(h.ShapeType.edge, t), l.a.addShapeDrawer(h.ShapeType.square, t), l.a.addShapeDrawer(h.ShapeType.triangle, new y()), l.a.addShapeDrawer(h.ShapeType.star, new f()), l.a.addShapeDrawer(h.ShapeType.polygon, new m()), l.a.addShapeDrawer(h.ShapeType.char, e), l.a.addShapeDrawer(h.ShapeType.character, e), l.a.addShapeDrawer(h.ShapeType.image, new b());\n      }\n\n      init() {\n        if (!this.initialized && (this.initialized = !0, \"undefined\" != typeof window && window)) {\n          const t = this;\n          window.particlesJS = (e, i) => {\n            t.load(e, i);\n          }, window.particlesJS.load = (e, i, o) => {\n            t.loadJSON(e, i).then(t => {\n              t && o(t);\n            });\n          }, window.particlesJS.setOnClickHandler = e => {\n            t.setOnClickHandler(e);\n          }, window.pJSDom = () => window.tsParticles.dom();\n        }\n      }\n\n      loadFromArray(t, e, i) {\n        return x(this, void 0, void 0, function* () {\n          return c.loadFromArray(t, e, i);\n        });\n      }\n\n      load(t, e) {\n        return x(this, void 0, void 0, function* () {\n          return c.load(t, e);\n        });\n      }\n\n      loadJSON(t, e) {\n        return c.loadJSON(t, e);\n      }\n\n      setOnClickHandler(t) {\n        c.setOnClickHandler(t);\n      }\n\n      dom() {\n        return c.dom();\n      }\n\n      domItem(t) {\n        return c.domItem(t);\n      }\n\n      addShape(t, e) {\n        let i;\n        i = \"function\" == typeof e ? {\n          draw: e\n        } : e, l.a.addShapeDrawer(t, i);\n      }\n\n      addPreset(t, e) {\n        w.a.addPreset(t, e);\n      }\n\n    }();\n    k.init();\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}